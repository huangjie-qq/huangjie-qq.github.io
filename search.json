[{"title":"利用反射+自定义注解 实现各种Bean之间的轻松转换","url":"/2021/10/26/demo2/","content":"Bean转换工具类默认按照字列名相同转换 不同时通过@Copy注解指定列名\nCopyUtils类：提供Bean转换方法\n@Copy注解： 用于映射列名不一样\n@Exclude注解：用于取消字段的映射 默认为true\n\nApi说明：\n单个Bean转换 :  T copy(Object source,Class targetClass)\n多个Bean转换 : List copy(List sourceList,Class targetClass)\nmap转Bean   :  T toBean(Map&lt;String,Object&gt; map,Class targetClass)\nBean转Map   :  Map&lt;String,Object&gt; toMap(Object target)\n\n注解用法   @Data\n   public class User &#123;\n    \n    private String name;\n    \n    private Integer age;\n    \n   &#125;\n \n   @Data\n   @Builder\n   public class UserVo &#123;\n    \n    @Copy(&quot;name&quot;)//指定要转换的列名\n    private String nameVo;\n    \n    private Integer age;\n    \n    @Exclude//排除该字段 默认为true\n    private String sex;\n    \n   &#125;\n   \n\n👉🏻快速开始   public static void main(String[] args) &#123;\n        \n        //单个Bean转换\n        UserVo userVo = UserVo.builder().nameVo(&quot;小球某&quot;).age(3).sex(&quot;男&quot;).build();\n        User user = CopyUtils.copy(userVo, User.class);\n        \n        //多个Bean转换\n        UserVo userVo1 = UserVo.builder().nameVo(&quot;张三&quot;).age(18).sex(&quot;男&quot;).build();\n        UserVo userVo2 = UserVo.builder().nameVo(&quot;李四&quot;).age(22).sex(&quot;男&quot;).build();\n        List&lt;UserVo&gt; userVoList = Arrays.asList(userVo1, userVo2);\n        List&lt;User&gt; userList = CopyUtils.copy(userVoList, User.class);\n        \n        //map转Bean\n        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n        map.put(&quot;name&quot;,&quot;小球某&quot;);\n        map.put(&quot;age&quot;,20);\n        User user = CopyUtils.toBean(map, User.class);\n        \n        //Bean转Map\n        Map&lt;String, Object&gt; map = CopyUtils.toMap(user);\n    &#125;\n   \n\n好用的同学💁🏻 点个星呗地址\n","tags":["java"]},{"title":"设计模式之建造者模式","url":"/2021/10/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","content":"介绍：建造者模式的定义是：将复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。\n为什么使用构建者模式？什么场景使用构建者模式？\n假如我们需要一个对象，一个对象的创建非常的复杂，对象中还要对象的封装，那么我们就可以使用构建者模式，将该对象的构建交给它来处理，我们使用的时候找他要一个对象就可以了。\n\n假如现在有个User类如下/**\n * @Author：小球某\n * @Date：2021/10/27/17:48\n */\n@Data\npublic class User &#123;\n\n    private String name;\n    private int age;\n    private String sex;\n    private String phone;\n    private String address;\n\n&#125;    \n\n当我们要构建name字段和age字段时 我们可以这样\npublic User(String name, int age) &#123;\n        this.name = name;\n        this.age = age;\n&#125;\n\n同理当需要构建 name字段 age字段  sex字段时\npublic User(String name, int age, String sex) &#123;\n        this.name = name;\n        this.age = age;\n        this.sex = sex;\n&#125;\n\n当我们每次需要构配不同对象时，就要为这些字段生成不同的构造函数，如此一来 我们的构造函数就特别多\n并且阅读性也特别的不好。\n当然还有一种解决办法 就是生成 get set方法   public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public void setSex(String sex) &#123;\n        this.sex = sex;\n    &#125;\n\n    public void setPhone(String phone) &#123;\n        this.phone = phone;\n    &#125;\n\n    public void setAddress(String address) &#123;\n        this.address = address;\n    &#125;\n\n写的时候这样就可以了\npublic static void main(String[] args) &#123;\n      User user=new User();\n      user.setName(&quot;小球某&quot;);\n      user.setAge(20);\n      user.setSex(&quot;男&quot;);\n&#125;\n\n这样一来就痛苦的是我们程序员了 这个时候构建者就来了\n首先来个静态内部类 字段和User类保持一致/**\n     * 内部类\n     */\n    public static class builder&#123;\n    \n        private String name;\n        private int age;\n        private String sex;\n        private String phone;\n        private String address;\n\n    &#125;\n\n提供构建各个字段的方法     public builder name(String name)&#123;\n         this.name=name;\n         return this;\n     &#125;\n\n     public builder age(int age)&#123;\n         this.age=age;\n         return this;\n     &#125;\n\n     public builder sex(String sex)&#123;\n         this.sex=sex;\n         return this;\n     &#125;\n\n     public builder phone(String phone)&#123;\n         this.phone=phone;\n         return this;\n     &#125;\n\n     public builder address(String address)&#123;\n         this.address=address;\n         return this;\n     &#125;\n\n最后提供构建build方法 同时在User提供构造函数public User build()&#123;\n   return new User(this);\n&#125;\n\npublic User(builder builder)&#123;\n        this.name= builder.name;\n        this.age= builder.age;\n        this.sex= builder.sex;\n        this.phone= builder.phone;\n        this.address= builder.address;\n &#125;\n\n完整代码/**\n * @Author：小球某\n * @Date：2021/10/27/17:48\n */\n@Data\npublic class User &#123;\n\n    private String name;\n    private int age;\n    private String sex;\n    private String phone;\n    private String address;\n\n\n    public User() &#123;\n    &#125;\n\n    public User(builder builder)&#123;\n        this.name= builder.name;\n        this.age= builder.age;\n        this.sex= builder.sex;\n        this.phone= builder.phone;\n        this.address= builder.address;\n    &#125;\n\n    /**\n     * 内部类\n     */\n    public static class builder&#123;\n    \n        private String name;\n        private int age;\n        private String sex;\n        private String phone;\n        private String address;\n\n        public builder name(String name)&#123;\n            this.name=name;\n            return this;\n        &#125;\n\n        public builder age(int age)&#123;\n            this.age=age;\n            return this;\n        &#125;\n\n        public builder sex(String sex)&#123;\n            this.sex=sex;\n            return this;\n        &#125;\n\n        public builder phone(String phone)&#123;\n            this.phone=phone;\n            return this;\n        &#125;\n\n        public builder address(String address)&#123;\n            this.address=address;\n            return this;\n        &#125;\n\n        public User build()&#123;\n            return new User(this);\n        &#125;\n\n    &#125;\n&#125;\n\n用法public static void main(String[] args) &#123;\n        User user1 = new User.builder().name(&quot;小球某&quot;).age(20).build();\n        User user2 = new User.builder().name(&quot;小球某&quot;).age(20).sex(&quot;男&quot;).build();\n        System.out.println(user1);\n        System.out.println(user2);\n&#125;\n\n运行结果如下：\nUser(name=小球某, age=20, sex=null, phone=null, address=null)\nUser(name=小球某, age=20, sex=男, phone=null, address=null)\n\n终极方法：lombok的Builder注解@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User &#123;\n\n    private String name;\n    private int age;\n    private String sex;\n    private String phone;\n    private String address;\n    \n&#125;\n\n用法 public static void main(String[] args) &#123;\n        User user = User.builder().name(&quot;小球某&quot;).age(20).sex(&quot;男&quot;).build();\n        System.out.println(user);\n &#125;\n\n运行结果如下：\nUser(name=小球某, age=20, sex=男, phone=null, address=null)\n\n","tags":["设计模式"]},{"title":"简单实现单点登录","url":"/2021/10/31/SSO-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/","content":"什么是单点登陆 ？\n用简单的话来讲就是 多个系统  一处登陆 处处登陆\n创建项目maven项目\n认证中心\n服务一\n服务二\n\n\n所有模块引入以下依赖\n &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--thymeleaf--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--redis缓存引入 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--lombok--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.16.20&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--fastjson--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n            &lt;version&gt;1.2.41&lt;/version&gt;\n        &lt;/dependency&gt;\n &lt;/dependencies&gt;\n\n认证中心配置如下：\n# 应用名称\nspring.application.name=attestation\nserver.port=8000\n\n# Redis服务器地址\nspring.redis.host=127.0.0.1\n# Redis服务器连接端口\nspring.redis.port=6379\n\nclient1配置如下：\n# 应用名称\nspring.application.name=client1\nserver.port=8100\n\n# Redis服务器地址\nspring.redis.host=127.0.0.1\n# Redis服务器连接端口\nspring.redis.port=6379\n\nclient2配置如下：\n# 应用名称\nspring.application.name=client2\nserver.port=8200\n\n# Redis服务器地址\nspring.redis.host=127.0.0.1\n# Redis服务器连接端口\nspring.redis.port=6379\n\n\n为了演示不同域名之间的登录 修改本地hosts文件（文件目录在C:\\Windows\\System32\\drivers\\etc）\n127.0.0.1 attestation.com\n\n127.0.0.1 client1\n\n127.0.0.1 client2\n\n在client1中  编写认证成功后才能访问的页面\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;SSO-服务一 认证成功&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n在client1编写一个简单的Controller\n/**\n * @Author：小球某\n * @Date：2021/10/31/0:03\n */\n@Controller\npublic class indexnController &#123;\n\n    @GetMapping(&quot;list&quot;)\n    public String list()&#123;\n        return &quot;list&quot;;\n    &#125;\n\n&#125;\n\n通过浏览器 访问：http://client1:8100/list  结果如下\n\n这个时候就要编写我们的认证逻辑 ，需要判断是否登录。\n正常通过session来判断用户是否登录 ，登录正常访问，未登录就重定向到我们的认证中心去。\n编写认证中心 登录页面和Controller&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;SSO-认证中心&lt;/h1&gt;\n&lt;form method=&quot;post&quot; action=&quot;&quot;&gt;\n    账号：&lt;input name=&quot;userName&quot; type=&quot;text&quot;&gt;&lt;br&gt;\n    密码：&lt;input name=&quot;password&quot; type=&quot;text&quot;&gt;&lt;br&gt;\n    登陆 &lt;input type=&quot;submit&quot;&gt;\n    &lt;input type=&quot;hidden&quot; name=&quot;url&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n@Controller\npublic class LoginController &#123;\n\n    /**\n     * 跳转到登录视图\n     * @return\n     */\n    @GetMapping(&quot;login.html&quot;)\n    public String loginPage()&#123;\n        return &quot;login&quot;;\n    &#125;\n\n    /**\n     * 处理登录逻辑\n     * @param user\n     * @return\n     */\n    @PostMapping(&quot;doLogin&quot;)\n    public String dolgoin(User user)&#123;\n        return null;\n    &#125;\n\n&#125;\n\n  @Data\n  public class User implements Serializable&#123;\n     private String userName;\n     private String password;\n  &#125;\n\nclient1代码 改动如下：\n    @GetMapping(&quot;list&quot;)\n    public String list(HttpSession session)&#123;\n        if(session.getAttribute(&quot;loginUser&quot;)==null)\n            return &quot;redirect:http://attestation.com:8000/login.html&quot;;\n        return &quot;list&quot;;\n    &#125;\n\n请求流程变成这样：\nclient1:8100/list —-》attestation.com:8000/login.html  —-》登录认证后  —-》attestation.com:8000/doLogin\n那么问题来了 当认证中心的dolgoin请求处理完成以后 要跳转到那里去呢？\n正常应该是跳转到client1:8100/list 中去 那么怎么才能正常跳转。\n可以在client1中跳转login.html请求的时候携带一个redirect_ur1参数，login.html请求接收这个URL，并将这个参数隐藏在前端， 提交dolgoin请求的时候传递这个URL即可。client1中代码改动如下：\n @GetMapping(&quot;list&quot;)\n    public String list(HttpSession session)&#123;\n        if(session.getAttribute(&quot;loginUser&quot;)==null)\n            return &quot;redirect:http://attestation.com:8000/login.html?redirect_ur1=http://client1:8100/list&quot;;\n        return &quot;list&quot;;\n    &#125;\n\nlogin请求改动如下：\n    @GetMapping(&quot;login.html&quot;)\n    public String loginPage(@RequestParam(&quot;redirect_ur1&quot;) String url, Model model)&#123;\n        model.addAttribute(&quot;url&quot;,url);\n        return &quot;login&quot;;\n    &#125;\n\n页面改动如下：\n&lt;form method=&quot;post&quot; action=&quot;doLogin&quot;&gt;\n    账号：&lt;input name=&quot;userName&quot; type=&quot;text&quot;&gt;&lt;br&gt;\n    密码：&lt;input name=&quot;password&quot; type=&quot;text&quot;&gt;&lt;br&gt;\n    &lt;input type=&quot;hidden&quot; name=&quot;url&quot; th:value=&quot;$&#123;url&#125;&quot;&gt;\n    登陆 &lt;input type=&quot;submit&quot;&gt;\n&lt;/form&gt;\n\n为了方便就将URL这个参数添加到User中去\n  @Data\n  public class User implements Serializable&#123;\n     private String userName;\n     private String password;\n     private String url;\n  &#125;\n\n这个时候dolgoin请求就可以正常的跳转回去了\n    @PostMapping(&quot;doLogin&quot;)\n    public String dolgoin(User user, HttpSession session)&#123;\n        session.setAttribute(&quot;loginUser&quot;,user);\n        return &quot;redirect:&quot;+user.getUrl();\n    &#125;\n\n改动完代码以后 并登陆后运行结果如下：\n\n明明登陆了 为什么还是会跳转到认证中心呢原因如下：在list请求中我们是通过session来判断是否登录， 虽然在认证中心登录， 但认证中心存的session\n client1是取不到  所以就会重新跳转到认证中心去。\n这个时候我们可以换一个思路，将认证中心存放的session 放入Redis中并将存入时放的key 在重定向的时候携带给client1 ， client1 中接收这个key来判断即可。认证中心代码变化如下：    @Resource\n    private RedisTemplate redisTemplate;\n\n    @PostMapping(&quot;doLogin&quot;)\n    public String dolgoin(User user)&#123;\n        String token= UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);\n        redisTemplate.opsForValue().set(token,JSON.toJSONString(user),30, TimeUnit.MINUTES);\n        return &quot;redirect:&quot;+user.getUrl()+&quot;?token=&quot;+token;\n    &#125;\n\nclient1代码变化如下：    @Resource\n    private RedisTemplate redisTemplate;\n\n    @GetMapping(&quot;list&quot;)\n    public String list(@RequestParam(value = &quot;token&quot;,required = false) String token, HttpSession session)&#123;\n        if(!StringUtils.isEmpty(token))&#123;\n            String json = (String) redisTemplate.opsForValue().get(token);\n            User loginUser = JSON.parseObject(json, User.class);\n            if(loginUser!=null)\n                session.setAttribute(&quot;loginUser&quot;,loginUser);\n        &#125;\n        if(session.getAttribute(&quot;loginUser&quot;)==null)\n            return &quot;redirect:http://attestation.com:8000/login.html?redirect_ur1=http://client1:8100/list&quot;;\n        return &quot;list&quot;;\n    &#125;\n\n为了看到认证后的效果 修改client1中HTML代码\n&lt;body&gt;\n&lt;h1&gt;SSO-服务一 认证成功&lt;/h1&gt;\n&lt;h1&gt;登录信息如下&lt;/h1&gt;\n&lt;h1 th:text=&quot;$&#123;session.loginUser==null?&#39;账号：未登录&#39;:&#39;账号：&#39;+session.loginUser.userName&#125;&quot;&gt;&lt;/h1&gt;\n&lt;h1 th:text=&quot;$&#123;session.loginUser==null?&#39;密码：未登录&#39;:&#39;密码：&#39;+session.loginUser.password&#125;&quot;&gt;&lt;/h1&gt;\n&lt;/body&gt;\n\n运行结果如下：访问http://client1:8100/list \n\n正常跳转到认证中心 登录后 正常显示\n\n这个时候我们把client1代码复制给client2，并修改重定向redirect_ur1参数变成client2的地址\n@GetMapping(&quot;list&quot;)\n    public String list(@RequestParam(value = &quot;token&quot;,required = false) String token, HttpSession session)&#123;\n        if(!StringUtils.isEmpty(token))&#123;\n            String json = (String) redisTemplate.opsForValue().get(token);\n            User loginUser = JSON.parseObject(json, User.class);\n            if(loginUser!=null)\n                session.setAttribute(&quot;loginUser&quot;,loginUser);\n        &#125;\n        if(session.getAttribute(&quot;loginUser&quot;)==null)\n            return &quot;redirect:http://attestation.com:8000/login.html?redirect_ur1=http://client2:8200/list&quot;;\n        return &quot;list&quot;;\n    &#125;\n\n 启动起来 访问：http://client2:8200/list\n\n为什么是还是会跳转到认证中心去 在client1中不是登录了吗分析代码：首先会判断token 我们没有token 然后会判断session 这个时候也没有 所以会重定向到认证中心去 \n这个时候我们可以在dolgoin请求登录后，在存入Redis的同时，在Cookie中也同时保存一份信息，并且在loginPage请求中判断是否有Cookie 如果有则证明有人登录过 直接跳转回去即可。认证中心代码变化如下：\n   /**\n     * 处理登录请求\n     * @param user\n     * @param response\n     * @return\n     */\n    @PostMapping(&quot;doLogin&quot;)\n    public String dolgoin(User user, HttpServletResponse response)&#123;\n        String token= UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);\n        redisTemplate.opsForValue().set(token,JSON.toJSONString(user),30, TimeUnit.MINUTES);\n        Cookie cookie = new Cookie(&quot;sso_token&quot;, token);\n        response.addCookie(cookie);\n        return &quot;redirect:&quot;+user.getUrl()+&quot;?token=&quot;+token;\n    &#125;\n\n    /**\n     * 跳转到登录视图\n     * @param url\n     * @param model \n     * @param token  \n     * @return\n     */\n    @GetMapping(&quot;login.html&quot;)\n    public String loginPage(@RequestParam(&quot;redirect_ur1&quot;) String url, Model model,\n                            @CookieValue(value = &quot;sso_token&quot;,required = false) String token)&#123;\n        if(!StringUtils.isEmpty(token))&#123;\n            return &quot;redirect:&quot;+url+&quot;?token=&quot;+token;\n        &#125;\n        model.addAttribute(&quot;url&quot;,url);\n        return &quot;login&quot;;\n    &#125;\n\n最后运行client2 访问：http://client2:8200/list\n\n 代码地址\n","tags":["java"]},{"title":"生产者/消费者模式","url":"/2021/11/05/%E7%94%9F%E6%88%90%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/","content":"一步一步走进生产消费者首我们创建一个普通java工程\n定义一个实现类 实现生产方法和消费方法 \n为了简单 我们就用使用普通的synchronized锁和  boolean变量来判断是否生产消费 \n/**\n * @Author：小球某\n * @Date：2021/11/06/0:01\n */\npublic class Realization &#123;\n    private Object lock;//锁\n    private boolean sign=true;//true生产 false消费 看好这个状态位 下面很重要\n\n    public Realization(Object lock) &#123;\n        this.lock = lock;\n    &#125;\n&#125;\n\n编写生产方法   /**\n     *生产方法\n     */\n    public void producer()&#123;\n        synchronized (lock)&#123;\n            try&#123;\n                if(!sign)\n                    lock.wait();\n                System.out.println(Thread.currentThread().getName()+&quot; 生产&quot;);\n                sign=false;\n                lock.notify();\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n编写消费者方法   /**\n     * 消费方法\n     */\n    public void consumer()&#123;\n        synchronized (lock)&#123;\n            try&#123;\n                if(sign)\n                    lock.wait();\n                System.out.println(Thread.currentThread().getName()+&quot; 消费&quot;);\n                sign=true;\n                lock.notify();\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n编写生产者/**\n * @Author：小球某\n * @Date：2021/11/06/00:16\n * 生产者\n */\npublic class Producer implements Runnable&#123;\n    private Realization realization;\n    \n    public Producer(Realization realization) &#123;\n        this.realization = realization;\n    &#125;\n    \n    @Override\n    public void run() &#123;\n        while (true)&#123;\n            realization.producer();\n        &#125;\n    &#125;\n&#125;\n\n编写消费者/**\n * @Author：小球某\n * @Date：2021/11/06/00:19\n * 消费者\n */\npublic class Consumer implements Runnable&#123;\n    private Realization realization;\n\n    public Consumer(Realization realization) &#123;\n        this.realization = realization;\n    &#125;\n    \n    @Override\n    public void run() &#123;\n       while (true)&#123;\n           realization.consumer();\n       &#125;   \n    &#125;\n&#125;\n\n最后编写Main测试public static void main(String[] args) &#123;\n\n    Realization realization = new Realization(new Object());\n\n    Producer producer = new Producer(realization);\n    Consumer consumer = new Consumer(realization);\n\n    new Thread(producer,&quot;生产者&quot;).start();\n    new Thread(consumer,&quot;消费者&quot;).start();\n&#125;\n\n运行结果如下：\n\n运行结果也不错 生产一个消费多个 没有什么问题\n但我们实际使用生产者消费者模式的时候一般是会多个生产者和消费者\n这个我们开启多个生产者和多个消费者 试一试我们的代码\npublic static void main(String[] args) &#123;\n\n        Realization realization = new Realization(new Object());\n\n        Producer producer = new Producer(realization);\n        Consumer consumer = new Consumer(realization);\n\n        new Thread(producer,&quot;生产者-1号&quot;).start();\n        new Thread(producer,&quot;生产者-2号&quot;).start();\n        new Thread(consumer,&quot;消费者-1号&quot;).start();\n        new Thread(consumer,&quot;消费者-2号&quot;).start();\n    &#125;\n\n运行结果如下：\n\n为什么会这种 生产一个 消费两次的情况呢？\n来看核心代码：\n1   if(sign)\n2       lock.wait();\n3   System.out.println(Thread.currentThread().getName()+&quot; 消费&quot;);\n4   sign=true;\n5   lock.notify();\n\n上面的boolean标记是默认是true，所以是要先生产 后消费\n现在我们来模拟 刚刚发送的情况的这种情况生产者:t1 t2 消费者：t3 t41步： t3得到调度 判断If  为  true  t3休眠  （休眠：t3   状态位：true）\n2步：恰巧t4也得到调度 和t3一样休眠 （休眠：t3  t4   状态位：true）\n3步：t1得到调度 首先判断if 要生产一个消息 然后改变状态位 用notify 唤醒了t3  (休眠：t4   状态位：false)\n4步：t3得到调度 从第2行代码醒来的t3 会接着往下执行3 4行代码 并改变状态位  唤醒的人是t4 (状态位：true)\n5步：t4得到调度  从第2行代码醒来的t4   会接着往下执行3 4行代码 改变状态位 唤醒\n其实在第5步 t4唤醒 往下执行的时候就错误了 状态位都是true \n问题出的地方就是 不管是生产者还是消费者 ，每次唤醒的时候 ，都要回头在看一下状态位是否正确 ，正确则继续执行 否则就继续休眠。\n解决办法：用while来判断状态位修改后的生产者方法   /**\n     *生产方法\n     */\n    public void producer()&#123;\n        synchronized (lock)&#123;\n            try&#123;\n                while(!sign)\n                    lock.wait();\n                System.out.println(Thread.currentThread().getName()+&quot; 生产&quot;);\n                sign=false;\n                lock.notify();\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n修改后的消费者方法   /**\n     * 消费方法\n     */\n    public void consumer()&#123;\n        synchronized (lock)&#123;\n            try&#123;\n                while(sign)\n                    lock.wait();\n                System.out.println(Thread.currentThread().getName()+&quot; 消费&quot;);\n                sign=true;\n                lock.notify();\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n修改完代码后 我们继续运行：\n\n可以看到程序是没有停止了 但为什么会没有运行下去呢？\n来看核心代码：\nlock.notify();\n\n现在我们来模拟 刚刚发送的情况的这种情况生产者:t1 t2 消费者：t3 t41步：t3得到调度 判断状态位 休眠  （休眠：t3）\n2步：t4得到调度  判断状态位 休眠   (休眠：t3  t4）\n3步：t1得到调度 判断状态位  生产 唤醒 t3   (休眠：t4)\n4步：t1又被调度  判断状态位 休眠   (休眠：t4  t1)\n5步：t2得到调度  判断状态位 休眠   (休眠：t4  t1  t2)\n6步：t3得到调度  判断状态位  消费  唤醒t4  (休眠：t1  t2)\n7步：t3又被调度  判断状态位  休眠  （休眠：t1 t2  t3）\n8步：只有t4存活 得到调度 判断状态位 休眠  （休眠：t1  t2 t3  t4）\n至此所以线程全部到了休眠状态 也没有其他线程会唤醒\n解决办法 使用lock.notifyAll();总结：在多生产者多线程的情况下，判断状态位的时候需要使用while判断 ，要不然可能会造成 一次生产多次消费，或者一次消费多次生产的情况，唤醒线程使用notifyAll() ,要不然可能会造成全部进入休眠状态 导致程序无法运行。当然这只是生产者 消费者的一种实现方法 还有其他多种实现方法。 代码地址\n","tags":["设计模式"]},{"title":"浅谈java三兄弟","url":"/2021/11/09/java%E4%B8%89%E5%85%84%E5%BC%9F/","content":"java对象模型 Java内存模型 JVM内存结构这三兄弟不要傻傻分不清\njava对象模型：就是咱们经常在代码中new的对象 对象保存在堆中，而我们在对对象进行操作时，其实操作的是对象的引用。\nJava对象包含三个部分一个Java对象可以分为三部分存储在内存中，分别是：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。\n\n\n对象头：默认存储 (哈希值(HashCode )、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳)等信息。\n实例数据：它是对象真正存储的有效信息,包括程序代码中定义的各种类型的字段。\n对齐填充：虚拟机要求对象起始地址是8字节的整数倍。填充数据不是必须存在的,只是为了字节对齐。\n\njava内存模型：Java内存模型也就是常说的JMM,是一组规范,需要各个JVM的实现来遵守JMM规范,以便于开发者可以利用这些规范,更方便地开发多线程程序。\n为什么会有这组规范？\n在C语言中不存在内存模型这样的概念，所以很多行为都是依赖处理器本身的，而不同的处理器之间对synchronized的理解不一样 会导致处理的结果也是不一样的。在一个处理上是一个结果，另一个处理上又是其他结果，也无法保证并发的安全。由于我们java是跨平台，所以迫切的需要一种规范来 让多线程运行的结果达到预期的结果。如果没有这样的一个JMM内存模型来规范,那么很可能经过了不同JVM的不同规则的重排序之后,导致不同的虚拟机上运行的结果不一样,那是很大的问题。\n在这些规范当中 最重要的三点就是：原子性、可见性、重排序\n原子性：用通俗的话来讲 操作不可中断 ，即使是在多线程情况下也不可中断，要不然执行成功 ,要不然不执行 。\n在java中的原子操作有 ：\n1.除了long和double之外的基本类型 赋值操作\n2.所有引用的赋值操作\n3.原子包下的原子类的操作\n可见性：保证多线程之间的修改变量 其他线程能够感知到。\nJMM有规定:\n1.所有的变量都存储在主内存中，同时每个线程有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝2.线程不能直接读写主内存中的变量，而是只能操作自己工作内存中的变量,然后再同步到主内存中3.主内存是多个线程共享的，但线程间不共享工作内存，如果线程间需要通信，必须借助主内存中转来完成所有的共享变量存在于主内存中，每个线程有自己的本地内存,而且线程读写共享数据，也是通过本地内存交换的，所以才导致了可见性问题。\n\n那么JMM怎么保证可见性呢：\n当我们的变量在Synchronize中或者被Volatile修饰时\n\n变量的写操作会立即刷到主内存中，确保其他线程可以获取到最新的值。\n变量的读操作会直接读取主内存中的值。\n\n当然Volatile只能保证变量的可见性 并不能像Synchronize还能保证原子性，在这里就不详细展开了。\n重排序：就是禁止重排序，那为什么会有重排序？：\n其实说到底都是源于对性能的优化，CPU运行效率 相比缓存、内存、硬盘IO之间效率有着指数级的差别，CPU作为系统的宝贵资源，那么如何更好的优化和利用这个资源就能提升整个计算机系统的性能\n从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序\n\n指令重排序的原则（as-if-serial语义）编译器和处理指令也并非什么场景都会进行指令重排序的优化，而是会遵循一定的原则，只有在它们认为重排序后不会对程序结果产生影响的时候才会进行重排序的优化，如果重排序会改变程序的结果，那这样的性能优化显然是没有意义的。而遵守as-if-serial 语义规则就是重排序的一个原则，as-if-serial 的意思是说，可以允许编译器和处理器进行重排序，但是有一个条件，就是不管怎么重排序都不能改变单线程执行程序的结果。\n1  a=1; //语句1\n2  b=2; //语句2\n3  a=a+3;\n\n对于上面代码的指令如下：\n1.Load a\n2.Set to 1\n3.Store a\n4.Load b\n5.Set to 2\n6.Store b\n7.Load a\n8.Set to 4\n9.Store a\n\nCPU会认为语句1和语句2没有关系 重排序后变成这样\n1  b=2;\n2  a=1;\n3  a=a+3;\n\n对于的指令如下：\n1.Load b\n2.Set to 2\n3.Store b\n4.Load a\n5.Set to 1\n6.Set to 4\n7.Store a\n\n经过重排序后将9条指令优化成7条，那么重排序会优化我们的程序 那么为什么jmm还会有禁止重排序呢？\n看下面代码\n  private static int value;\n     private static boolean flag;\n \n     public static  void  init()&#123;\n         value=1;     //语句1\n         flag=true;  //语句2\n     &#125;\n \n     public static void getValue()&#123;\n         if(flag)&#123;\n             System.out.println(value);\n         &#125;\n     &#125;\n\n在单线程情况下 如果代码没有发送重排序 那么先运行init() 再运行 getValue()方法  打印的结果 肯定是1\n当cpu认为语句1和语句2没有关系时 进行了重排序可能会变成这样\n   public static  void  init()&#123;\n         flag=true;  //语句2\n         value=1;    //语句1\n     &#125;\n\n这个时候两个线程分别调用 init()和getValue()方法，那么就有可能出现这种情况\n线程一 执行 init() 当执行到   flag=true; 时  \n线程二 马上执行完 getValue()方法 然后会打印0\n然后线程一在把  value=1; 执行完毕。\n这样就是导致和我们预期的结果不一致 ,我们预期的结果是调用  getValue()方法打印1出来 。\n所以在复杂的多线程环境下，编译器和处理器是根本无法通过语义分析来知道代码指令的依赖关系的，所以这个问题只交给能写代码的人才能清楚的知道，这个时候编写代码的人就需要通过一种方式显示的告诉编译器和处理器哪些地方是存在逻辑依赖的，这些地方不能进行重排序。\n使用Volatile就能保证禁止重排序JVM内存结构Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。\n每个区域都有各自的作用。\n\n上面图中 绿色区域都是线程共享的  黄色区域都是线程私有的。\n程序计数器：是记住下一条jvm指令的执行地址 当执行的是Native方法是为0  ,是线程私有 和其他区不同的是 程序计数器永远不会内存溢出。\njava栈：每当启动一个新线程时，Java虚拟机都会为它分配一个Java栈。Java栈以帧为单位保存线程的运行状态。虚拟机只会直接对Java栈执行两种操作：以帧为单位的压栈和出栈。\n　　某个线程正在执行的方法被称为该线程的当前方法，当前方法使用的栈帧称为当前帧，当前方法所属的类称为当前类，当前类的常量池称为当前常量池。在线程执行一个方法时，它会跟踪当前类和当前常量池。此外，当虚拟机遇到栈内操作指令时，它对当前帧内数据执行操作。\n　　每当线程调用一个Java方法时，虚拟机都会在该线程的Java栈中压入一个新帧。而这个新帧自然就成为了当前帧。在执行这个方法时，它使用这个帧来存储参数、局部变量、中间运算结果等数据。\n　　Java方法可以以两种方式完成。一种通过return返回的，称为正常返回；一种是通过抛出异常而异常终止的。不管以哪种方式返回，虚拟机都会将当前帧弹出Java栈然后释放掉，这样上一个方法的帧就成为当前帧了。\n　　Java帧上的所有数据都是此线程私有的。任何线程都不能访问另一个线程的栈数据，因此我们不需要考虑多线程情况下栈数据的访问同步问题。当一个线程调用一个方法时，方法的的局部变量保存在调用线程Java栈的帧中。只有一个线程能总是访问那些局部变量，即调用方法的线程。\n本地方法栈：Java 虚拟机的实现可以使用传统的堆栈，通俗地称为“C 堆栈”，以支持native方法（用 Java 编程语言以外的语言编写的方法）。本机方法堆栈也可以由 Java 虚拟机指令集的解释器实现使用，例如 C 语言。无法加载native 方法且本身不依赖常规堆栈的Java 虚拟机实现不需要提供本机方法堆栈. 如果提供，则通常在创建每个线程时为每个线程分配本机方法堆栈。\n堆区：Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的堆。堆是运行时数据区，从中分配所有类实例和数组的内存，线程共享的。\n方法区：Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区。方法区类似于传统语言的编译代码存储区，或类似于操作系统进程中的“文本”段。它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化和接口初始化中使用的特殊方法。\n1.6在堆区中使用 永久代实现 ，1.8使用堆外内存 元空间实现。\n使用元空间的好处是\n1.字符串常量池存在永久代中,容易出现性能问题和内存溢出2.类和方法的信息大小难易确定,给永久代的大小指定带来困难3.永久代会为GC带来不必要的复杂性\n","tags":["java"]}]