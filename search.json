[{"title":"利用反射+自定义注解 实现各种Bean之间的轻松转换","url":"/2021/10/26/demo2/","content":"Bean转换工具类默认按照字列名相同转换 不同时通过@Copy注解指定列名\nCopyUtils类：提供Bean转换方法\n@Copy注解： 用于映射列名不一样\n@Exclude注解：用于取消字段的映射 默认为true\n\nApi说明：\n单个Bean转换 :  T copy(Object source,Class targetClass)\n多个Bean转换 : List copy(List sourceList,Class targetClass)\nmap转Bean   :  T toBean(Map&lt;String,Object&gt; map,Class targetClass)\nBean转Map   :  Map&lt;String,Object&gt; toMap(Object target)\n\n注解用法   @Data\n   public class User &#123;\n    \n    private String name;\n    \n    private Integer age;\n    \n   &#125;\n \n   @Data\n   @Builder\n   public class UserVo &#123;\n    \n    @Copy(&quot;name&quot;)//指定要转换的列名\n    private String nameVo;\n    \n    private Integer age;\n    \n    @Exclude//排除该字段 默认为true\n    private String sex;\n    \n   &#125;\n   \n\n👉🏻快速开始   public static void main(String[] args) &#123;\n        \n        //单个Bean转换\n        UserVo userVo = UserVo.builder().nameVo(&quot;小球某&quot;).age(3).sex(&quot;男&quot;).build();\n        User user = CopyUtils.copy(userVo, User.class);\n        \n        //多个Bean转换\n        UserVo userVo1 = UserVo.builder().nameVo(&quot;张三&quot;).age(18).sex(&quot;男&quot;).build();\n        UserVo userVo2 = UserVo.builder().nameVo(&quot;李四&quot;).age(22).sex(&quot;男&quot;).build();\n        List&lt;UserVo&gt; userVoList = Arrays.asList(userVo1, userVo2);\n        List&lt;User&gt; userList = CopyUtils.copy(userVoList, User.class);\n        \n        //map转Bean\n        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n        map.put(&quot;name&quot;,&quot;小球某&quot;);\n        map.put(&quot;age&quot;,20);\n        User user = CopyUtils.toBean(map, User.class);\n        \n        //Bean转Map\n        Map&lt;String, Object&gt; map = CopyUtils.toMap(user);\n    &#125;\n   \n\n好用的同学💁🏻 点个星呗地址\n","tags":["java"]},{"title":"设计模式之建造者模式","url":"/2021/10/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","content":"介绍：建造者模式的定义是：将复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。\n为什么使用构建者模式？什么场景使用构建者模式？\n假如我们需要一个对象，一个对象的创建非常的复杂，对象中还要对象的封装，那么我们就可以使用构建者模式，将该对象的构建交给它来处理，我们使用的时候找他要一个对象就可以了。\n\n假如现在有个User类如下/**\n * @Author：小球某\n * @Date：2021/10/27/17:48\n */\n@Data\npublic class User &#123;\n\n    private String name;\n    private int age;\n    private String sex;\n    private String phone;\n    private String address;\n\n&#125;    \n\n当我们要构建name字段和age字段时 我们可以这样\npublic User(String name, int age) &#123;\n        this.name = name;\n        this.age = age;\n&#125;\n\n同理当需要构建 name字段 age字段  sex字段时\npublic User(String name, int age, String sex) &#123;\n        this.name = name;\n        this.age = age;\n        this.sex = sex;\n&#125;\n\n当我们每次需要构配不同对象时，就要为这些字段生成不同的构造函数，如此一来 我们的构造函数就特别多\n并且阅读性也特别的不好。\n当然还有一种解决办法 就是生成 get set方法   public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public void setSex(String sex) &#123;\n        this.sex = sex;\n    &#125;\n\n    public void setPhone(String phone) &#123;\n        this.phone = phone;\n    &#125;\n\n    public void setAddress(String address) &#123;\n        this.address = address;\n    &#125;\n\n写的时候这样就可以了\npublic static void main(String[] args) &#123;\n      User user=new User();\n      user.setName(&quot;小球某&quot;);\n      user.setAge(20);\n      user.setSex(&quot;男&quot;);\n&#125;\n\n这样一来就痛苦的是我们程序员了 这个时候构建者就来了\n首先来个静态内部类 字段和User类保持一致/**\n     * 内部类\n     */\n    public static class builder&#123;\n    \n        private String name;\n        private int age;\n        private String sex;\n        private String phone;\n        private String address;\n\n    &#125;\n\n提供构建各个字段的方法     public builder name(String name)&#123;\n         this.name=name;\n         return this;\n     &#125;\n\n     public builder age(int age)&#123;\n         this.age=age;\n         return this;\n     &#125;\n\n     public builder sex(String sex)&#123;\n         this.sex=sex;\n         return this;\n     &#125;\n\n     public builder phone(String phone)&#123;\n         this.phone=phone;\n         return this;\n     &#125;\n\n     public builder address(String address)&#123;\n         this.address=address;\n         return this;\n     &#125;\n\n最后提供构建build方法 同时在User提供构造函数public User build()&#123;\n   return new User(this);\n&#125;\n\npublic User(builder builder)&#123;\n        this.name= builder.name;\n        this.age= builder.age;\n        this.sex= builder.sex;\n        this.phone= builder.phone;\n        this.address= builder.address;\n &#125;\n\n完整代码/**\n * @Author：小球某\n * @Date：2021/10/27/17:48\n */\n@Data\npublic class User &#123;\n\n    private String name;\n    private int age;\n    private String sex;\n    private String phone;\n    private String address;\n\n\n    public User() &#123;\n    &#125;\n\n    public User(builder builder)&#123;\n        this.name= builder.name;\n        this.age= builder.age;\n        this.sex= builder.sex;\n        this.phone= builder.phone;\n        this.address= builder.address;\n    &#125;\n\n    /**\n     * 内部类\n     */\n    public static class builder&#123;\n    \n        private String name;\n        private int age;\n        private String sex;\n        private String phone;\n        private String address;\n\n        public builder name(String name)&#123;\n            this.name=name;\n            return this;\n        &#125;\n\n        public builder age(int age)&#123;\n            this.age=age;\n            return this;\n        &#125;\n\n        public builder sex(String sex)&#123;\n            this.sex=sex;\n            return this;\n        &#125;\n\n        public builder phone(String phone)&#123;\n            this.phone=phone;\n            return this;\n        &#125;\n\n        public builder address(String address)&#123;\n            this.address=address;\n            return this;\n        &#125;\n\n        public User build()&#123;\n            return new User(this);\n        &#125;\n\n    &#125;\n&#125;\n\n用法public static void main(String[] args) &#123;\n        User user1 = new User.builder().name(&quot;小球某&quot;).age(20).build();\n        User user2 = new User.builder().name(&quot;小球某&quot;).age(20).sex(&quot;男&quot;).build();\n        System.out.println(user1);\n        System.out.println(user2);\n&#125;\n\n运行结果如下：\nUser(name=小球某, age=20, sex=null, phone=null, address=null)\nUser(name=小球某, age=20, sex=男, phone=null, address=null)\n\n终极方法：lombok的Builder注解@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User &#123;\n\n    private String name;\n    private int age;\n    private String sex;\n    private String phone;\n    private String address;\n    \n&#125;\n\n用法 public static void main(String[] args) &#123;\n        User user = User.builder().name(&quot;小球某&quot;).age(20).sex(&quot;男&quot;).build();\n        System.out.println(user);\n &#125;\n\n运行结果如下：\nUser(name=小球某, age=20, sex=男, phone=null, address=null)\n\n","tags":["设计模式"]},{"title":"简单实现单点登录","url":"/2021/10/31/SSO-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/","content":"什么是单点登陆 ？\n用简单的话来讲就是 多个系统  一处登陆 处处登陆\n创建项目maven项目\n认证中心\n服务一\n服务二\n\n\n所有模块引入以下依赖\n &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--thymeleaf--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--redis缓存引入 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--lombok--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.16.20&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--fastjson--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n            &lt;version&gt;1.2.41&lt;/version&gt;\n        &lt;/dependency&gt;\n &lt;/dependencies&gt;\n\n认证中心配置如下：\n# 应用名称\nspring.application.name=attestation\nserver.port=8000\n\n# Redis服务器地址\nspring.redis.host=127.0.0.1\n# Redis服务器连接端口\nspring.redis.port=6379\n\nclient1配置如下：\n# 应用名称\nspring.application.name=client1\nserver.port=8100\n\n# Redis服务器地址\nspring.redis.host=127.0.0.1\n# Redis服务器连接端口\nspring.redis.port=6379\n\nclient2配置如下：\n# 应用名称\nspring.application.name=client2\nserver.port=8200\n\n# Redis服务器地址\nspring.redis.host=127.0.0.1\n# Redis服务器连接端口\nspring.redis.port=6379\n\n\n为了演示不同域名之间的登录 修改本地hosts文件（文件目录在C:\\Windows\\System32\\drivers\\etc）\n127.0.0.1 attestation.com\n\n127.0.0.1 client1\n\n127.0.0.1 client2\n\n在client1中  编写认证成功后才能访问的页面\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;SSO-服务一 认证成功&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n在client1编写一个简单的Controller\n/**\n * @Author：小球某\n * @Date：2021/10/31/0:03\n */\n@Controller\npublic class indexnController &#123;\n\n    @GetMapping(&quot;list&quot;)\n    public String list()&#123;\n        return &quot;list&quot;;\n    &#125;\n\n&#125;\n\n通过浏览器 访问：http://client1:8100/list  结果如下\n\n这个时候就要编写我们的认证逻辑 ，需要判断是否登录。\n正常通过session来判断用户是否登录 ，登录正常访问，未登录就重定向到我们的认证中心去。\n编写认证中心 登录页面和Controller&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;SSO-认证中心&lt;/h1&gt;\n&lt;form method=&quot;post&quot; action=&quot;&quot;&gt;\n    账号：&lt;input name=&quot;userName&quot; type=&quot;text&quot;&gt;&lt;br&gt;\n    密码：&lt;input name=&quot;password&quot; type=&quot;text&quot;&gt;&lt;br&gt;\n    登陆 &lt;input type=&quot;submit&quot;&gt;\n    &lt;input type=&quot;hidden&quot; name=&quot;url&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n@Controller\npublic class LoginController &#123;\n\n    /**\n     * 跳转到登录视图\n     * @return\n     */\n    @GetMapping(&quot;login.html&quot;)\n    public String loginPage()&#123;\n        return &quot;login&quot;;\n    &#125;\n\n    /**\n     * 处理登录逻辑\n     * @param user\n     * @return\n     */\n    @PostMapping(&quot;doLogin&quot;)\n    public String dolgoin(User user)&#123;\n        return null;\n    &#125;\n\n&#125;\n\n  @Data\n  public class User implements Serializable&#123;\n     private String userName;\n     private String password;\n  &#125;\n\nclient1代码 改动如下：\n    @GetMapping(&quot;list&quot;)\n    public String list(HttpSession session)&#123;\n        if(session.getAttribute(&quot;loginUser&quot;)==null)\n            return &quot;redirect:http://attestation.com:8000/login.html&quot;;\n        return &quot;list&quot;;\n    &#125;\n\n请求流程变成这样：\nclient1:8100/list —-》attestation.com:8000/login.html  —-》登录认证后  —-》attestation.com:8000/doLogin\n那么问题来了 当认证中心的dolgoin请求处理完成以后 要跳转到那里去呢？\n正常应该是跳转到client1:8100/list 中去 那么怎么才能正常跳转。\n可以在client1中跳转login.html请求的时候携带一个redirect_ur1参数，login.html请求接收这个URL，并将这个参数隐藏在前端， 提交dolgoin请求的时候传递这个URL即可。client1中代码改动如下：\n @GetMapping(&quot;list&quot;)\n    public String list(HttpSession session)&#123;\n        if(session.getAttribute(&quot;loginUser&quot;)==null)\n            return &quot;redirect:http://attestation.com:8000/login.html?redirect_ur1=http://client1:8100/list&quot;;\n        return &quot;list&quot;;\n    &#125;\n\nlogin请求改动如下：\n    @GetMapping(&quot;login.html&quot;)\n    public String loginPage(@RequestParam(&quot;redirect_ur1&quot;) String url, Model model)&#123;\n        model.addAttribute(&quot;url&quot;,url);\n        return &quot;login&quot;;\n    &#125;\n\n页面改动如下：\n&lt;form method=&quot;post&quot; action=&quot;doLogin&quot;&gt;\n    账号：&lt;input name=&quot;userName&quot; type=&quot;text&quot;&gt;&lt;br&gt;\n    密码：&lt;input name=&quot;password&quot; type=&quot;text&quot;&gt;&lt;br&gt;\n    &lt;input type=&quot;hidden&quot; name=&quot;url&quot; th:value=&quot;$&#123;url&#125;&quot;&gt;\n    登陆 &lt;input type=&quot;submit&quot;&gt;\n&lt;/form&gt;\n\n为了方便就将URL这个参数添加到User中去\n  @Data\n  public class User implements Serializable&#123;\n     private String userName;\n     private String password;\n     private String url;\n  &#125;\n\n这个时候dolgoin请求就可以正常的跳转回去了\n    @PostMapping(&quot;doLogin&quot;)\n    public String dolgoin(User user, HttpSession session)&#123;\n        session.setAttribute(&quot;loginUser&quot;,user);\n        return &quot;redirect:&quot;+user.getUrl();\n    &#125;\n\n改动完代码以后 并登陆后运行结果如下：\n\n明明登陆了 为什么还是会跳转到认证中心呢原因如下：在list请求中我们是通过session来判断是否登录， 虽然在认证中心登录， 但认证中心存的session\n client1是取不到  所以就会重新跳转到认证中心去。\n这个时候我们可以换一个思路，将认证中心存放的session 放入Redis中并将存入时放的key 在重定向的时候携带给client1 ， client1 中接收这个key来判断即可。认证中心代码变化如下：    @Resource\n    private RedisTemplate redisTemplate;\n\n    @PostMapping(&quot;doLogin&quot;)\n    public String dolgoin(User user)&#123;\n        String token= UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);\n        redisTemplate.opsForValue().set(token,JSON.toJSONString(user),30, TimeUnit.MINUTES);\n        return &quot;redirect:&quot;+user.getUrl()+&quot;?token=&quot;+token;\n    &#125;\n\nclient1代码变化如下：    @Resource\n    private RedisTemplate redisTemplate;\n\n    @GetMapping(&quot;list&quot;)\n    public String list(@RequestParam(value = &quot;token&quot;,required = false) String token, HttpSession session)&#123;\n        if(!StringUtils.isEmpty(token))&#123;\n            String json = (String) redisTemplate.opsForValue().get(token);\n            User loginUser = JSON.parseObject(json, User.class);\n            if(loginUser!=null)\n                session.setAttribute(&quot;loginUser&quot;,loginUser);\n        &#125;\n        if(session.getAttribute(&quot;loginUser&quot;)==null)\n            return &quot;redirect:http://attestation.com:8000/login.html?redirect_ur1=http://client1:8100/list&quot;;\n        return &quot;list&quot;;\n    &#125;\n\n为了看到认证后的效果 修改client1中HTML代码\n&lt;body&gt;\n&lt;h1&gt;SSO-服务一 认证成功&lt;/h1&gt;\n&lt;h1&gt;登录信息如下&lt;/h1&gt;\n&lt;h1 th:text=&quot;$&#123;session.loginUser==null?&#39;账号：未登录&#39;:&#39;账号：&#39;+session.loginUser.userName&#125;&quot;&gt;&lt;/h1&gt;\n&lt;h1 th:text=&quot;$&#123;session.loginUser==null?&#39;密码：未登录&#39;:&#39;密码：&#39;+session.loginUser.password&#125;&quot;&gt;&lt;/h1&gt;\n&lt;/body&gt;\n\n运行结果如下：访问http://client1:8100/list \n\n正常跳转到认证中心 登录后 正常显示\n\n这个时候我们把client1代码复制给client2，并修改重定向redirect_ur1参数变成client2的地址\n@GetMapping(&quot;list&quot;)\n    public String list(@RequestParam(value = &quot;token&quot;,required = false) String token, HttpSession session)&#123;\n        if(!StringUtils.isEmpty(token))&#123;\n            String json = (String) redisTemplate.opsForValue().get(token);\n            User loginUser = JSON.parseObject(json, User.class);\n            if(loginUser!=null)\n                session.setAttribute(&quot;loginUser&quot;,loginUser);\n        &#125;\n        if(session.getAttribute(&quot;loginUser&quot;)==null)\n            return &quot;redirect:http://attestation.com:8000/login.html?redirect_ur1=http://client2:8200/list&quot;;\n        return &quot;list&quot;;\n    &#125;\n\n 启动起来 访问：http://client2:8200/list\n\n为什么是还是会跳转到认证中心去 在client1中不是登录了吗分析代码：首先会判断token 我们没有token 然后会判断session 这个时候也没有 所以会重定向到认证中心去 \n这个时候我们可以在dolgoin请求登录后，在存入Redis的同时，在Cookie中也同时保存一份信息，并且在loginPage请求中判断是否有Cookie 如果有则证明有人登录过 直接跳转回去即可。认证中心代码变化如下：\n   /**\n     * 处理登录请求\n     * @param user\n     * @param response\n     * @return\n     */\n    @PostMapping(&quot;doLogin&quot;)\n    public String dolgoin(User user, HttpServletResponse response)&#123;\n        String token= UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);\n        redisTemplate.opsForValue().set(token,JSON.toJSONString(user),30, TimeUnit.MINUTES);\n        Cookie cookie = new Cookie(&quot;sso_token&quot;, token);\n        response.addCookie(cookie);\n        return &quot;redirect:&quot;+user.getUrl()+&quot;?token=&quot;+token;\n    &#125;\n\n    /**\n     * 跳转到登录视图\n     * @param url\n     * @param model \n     * @param token  \n     * @return\n     */\n    @GetMapping(&quot;login.html&quot;)\n    public String loginPage(@RequestParam(&quot;redirect_ur1&quot;) String url, Model model,\n                            @CookieValue(value = &quot;sso_token&quot;,required = false) String token)&#123;\n        if(!StringUtils.isEmpty(token))&#123;\n            return &quot;redirect:&quot;+url+&quot;?token=&quot;+token;\n        &#125;\n        model.addAttribute(&quot;url&quot;,url);\n        return &quot;login&quot;;\n    &#125;\n\n最后运行client2 访问：http://client2:8200/list\n\n​     代码地址：https://github.com/huangjie-qq/sso\n","tags":["java"]},{"title":"生产者/消费者模式","url":"/2021/11/05/%E7%94%9F%E6%88%90%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/","content":"一步一步走进生产消费者首我们创建一个普通java工程\n定义一个实现类 实现生产方法和消费方法 \n为了简单 我们就用使用普通的synchronized锁和  boolean变量来判断是否生产消费 \n/**\n * @Author：小球某\n * @Date：2021/11/06/0:01\n */\npublic class Realization &#123;\n    private Object lock;//锁\n    private boolean sign=true;//true生产 false消费 看好这个状态位 下面很重要\n\n    public Realization(Object lock) &#123;\n        this.lock = lock;\n    &#125;\n&#125;\n\n编写生产方法   /**\n     *生产方法\n     */\n    public void producer()&#123;\n        synchronized (lock)&#123;\n            try&#123;\n                if(!sign)\n                    lock.wait();\n                System.out.println(Thread.currentThread().getName()+&quot; 生产&quot;);\n                sign=false;\n                lock.notify();\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n编写消费者方法   /**\n     * 消费方法\n     */\n    public void consumer()&#123;\n        synchronized (lock)&#123;\n            try&#123;\n                if(sign)\n                    lock.wait();\n                System.out.println(Thread.currentThread().getName()+&quot; 消费&quot;);\n                sign=true;\n                lock.notify();\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n编写生产者/**\n * @Author：小球某\n * @Date：2021/11/06/00:16\n * 生产者\n */\npublic class Producer implements Runnable&#123;\n    private Realization realization;\n    \n    public Producer(Realization realization) &#123;\n        this.realization = realization;\n    &#125;\n    \n    @Override\n    public void run() &#123;\n        while (true)&#123;\n            realization.producer();\n        &#125;\n    &#125;\n&#125;\n\n编写消费者/**\n * @Author：小球某\n * @Date：2021/11/06/00:19\n * 消费者\n */\npublic class Consumer implements Runnable&#123;\n    private Realization realization;\n\n    public Consumer(Realization realization) &#123;\n        this.realization = realization;\n    &#125;\n    \n    @Override\n    public void run() &#123;\n       while (true)&#123;\n           realization.consumer();\n       &#125;   \n    &#125;\n&#125;\n\n最后编写Main测试public static void main(String[] args) &#123;\n\n    Realization realization = new Realization(new Object());\n\n    Producer producer = new Producer(realization);\n    Consumer consumer = new Consumer(realization);\n\n    new Thread(producer,&quot;生产者&quot;).start();\n    new Thread(consumer,&quot;消费者&quot;).start();\n&#125;\n\n运行结果如下：\n\n运行结果也不错 生产一个消费多个 没有什么问题\n但我们实际使用生产者消费者模式的时候一般是会多个生产者和消费者\n这个我们开启多个生产者和多个消费者 试一试我们的代码\npublic static void main(String[] args) &#123;\n\n        Realization realization = new Realization(new Object());\n\n        Producer producer = new Producer(realization);\n        Consumer consumer = new Consumer(realization);\n\n        new Thread(producer,&quot;生产者-1号&quot;).start();\n        new Thread(producer,&quot;生产者-2号&quot;).start();\n        new Thread(consumer,&quot;消费者-1号&quot;).start();\n        new Thread(consumer,&quot;消费者-2号&quot;).start();\n    &#125;\n\n运行结果如下：\n\n为什么会这种 生产一个 消费两次的情况呢？\n来看核心代码：\n1   if(sign)\n2       lock.wait();\n3   System.out.println(Thread.currentThread().getName()+&quot; 消费&quot;);\n4   sign=true;\n5   lock.notify();\n\n上面的boolean标记是默认是true，所以是要先生产 后消费\n现在我们来模拟 刚刚发送的情况的这种情况生产者:t1 t2 消费者：t3 t41步： t3得到调度 判断If  为  true  t3休眠  （休眠：t3   状态位：true）\n2步：恰巧t4也得到调度 和t3一样休眠 （休眠：t3  t4   状态位：true）\n3步：t1得到调度 首先判断if 要生产一个消息 然后改变状态位 用notify 唤醒了t3  (休眠：t4   状态位：false)\n4步：t3得到调度 从第2行代码醒来的t3 会接着往下执行3 4行代码 并改变状态位  唤醒的人是t4 (状态位：true)\n5步：t4得到调度  从第2行代码醒来的t4   会接着往下执行3 4行代码 改变状态位 唤醒\n其实在第5步 t4唤醒 往下执行的时候就错误了 状态位都是true \n问题出的地方就是 不管是生产者还是消费者 ，每次唤醒的时候 ，都要回头在看一下状态位是否正确 ，正确则继续执行 否则就继续休眠。\n解决办法：用while来判断状态位修改后的生产者方法   /**\n     *生产方法\n     */\n    public void producer()&#123;\n        synchronized (lock)&#123;\n            try&#123;\n                while(!sign)\n                    lock.wait();\n                System.out.println(Thread.currentThread().getName()+&quot; 生产&quot;);\n                sign=false;\n                lock.notify();\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n修改后的消费者方法   /**\n     * 消费方法\n     */\n    public void consumer()&#123;\n        synchronized (lock)&#123;\n            try&#123;\n                while(sign)\n                    lock.wait();\n                System.out.println(Thread.currentThread().getName()+&quot; 消费&quot;);\n                sign=true;\n                lock.notify();\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n修改完代码后 我们继续运行：\n\n可以看到程序是没有停止了 但为什么会没有运行下去呢？\n来看核心代码：\nlock.notify();\n\n现在我们来模拟 刚刚发送的情况的这种情况生产者:t1 t2 消费者：t3 t41步：t3得到调度 判断状态位 休眠  （休眠：t3）\n2步：t4得到调度  判断状态位 休眠   (休眠：t3  t4）\n3步：t1得到调度 判断状态位  生产 唤醒 t3   (休眠：t4)\n4步：t1又被调度  判断状态位 休眠   (休眠：t4  t1)\n5步：t2得到调度  判断状态位 休眠   (休眠：t4  t1  t2)\n6步：t3得到调度  判断状态位  消费  唤醒t4  (休眠：t1  t2)\n7步：t3又被调度  判断状态位  休眠  （休眠：t1 t2  t3）\n8步：只有t4存活 得到调度 判断状态位 休眠  （休眠：t1  t2 t3  t4）\n至此所以线程全部到了休眠状态 也没有其他线程会唤醒\n解决办法 使用lock.notifyAll();总结：在多生产者多线程的情况下，判断状态位的时候需要使用while判断 ，要不然可能会造成 一次生产多次消费，或者一次消费多次生产的情况，唤醒线程使用notifyAll() ,要不然可能会造成全部进入休眠状态 导致程序无法运行。当然这只是生产者 消费者的一种实现方法 还有其他多种实现方法。","tags":["设计模式"]}]