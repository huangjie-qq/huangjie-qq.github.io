[{"title":"利用反射+自定义注解 实现各种Bean之间的轻松转换","url":"/2021/10/26/demo2/","content":"Bean转换工具类默认按照字列名相同转换 不同时通过@Copy注解指定列名\nCopyUtils类：提供Bean转换方法\n@Copy注解： 用于映射列名不一样\n@Exclude注解：用于取消字段的映射 默认为true\n\nApi说明：\n单个Bean转换 :  T copy(Object source,Class targetClass)\n多个Bean转换 : List copy(List sourceList,Class targetClass)\nmap转Bean   :  T toBean(Map&lt;String,Object&gt; map,Class targetClass)\nBean转Map   :  Map&lt;String,Object&gt; toMap(Object target)\n\n注解用法   @Data\n   public class User &#123;\n    \n    private String name;\n    \n    private Integer age;\n    \n   &#125;\n \n   @Data\n   @Builder\n   public class UserVo &#123;\n    \n    @Copy(&quot;name&quot;)//指定要转换的列名\n    private String nameVo;\n    \n    private Integer age;\n    \n    @Exclude//排除该字段 默认为true\n    private String sex;\n    \n   &#125;\n   \n\n👉🏻快速开始   public static void main(String[] args) &#123;\n        \n        //单个Bean转换\n        UserVo userVo = UserVo.builder().nameVo(&quot;小球某&quot;).age(3).sex(&quot;男&quot;).build();\n        User user = CopyUtils.copy(userVo, User.class);\n        \n        //多个Bean转换\n        UserVo userVo1 = UserVo.builder().nameVo(&quot;张三&quot;).age(18).sex(&quot;男&quot;).build();\n        UserVo userVo2 = UserVo.builder().nameVo(&quot;李四&quot;).age(22).sex(&quot;男&quot;).build();\n        List&lt;UserVo&gt; userVoList = Arrays.asList(userVo1, userVo2);\n        List&lt;User&gt; userList = CopyUtils.copy(userVoList, User.class);\n        \n        //map转Bean\n        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n        map.put(&quot;name&quot;,&quot;小球某&quot;);\n        map.put(&quot;age&quot;,20);\n        User user = CopyUtils.toBean(map, User.class);\n        \n        //Bean转Map\n        Map&lt;String, Object&gt; map = CopyUtils.toMap(user);\n    &#125;\n   \n\n好用的同学💁🏻 点个星呗地址\n","tags":["java"]},{"title":"设计模式之建造者模式","url":"/2021/10/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/","content":"介绍：建造者模式的定义是：将复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。\n为什么使用构建者模式？什么场景使用构建者模式？\n假如我们需要一个对象，一个对象的创建非常的复杂，对象中还要对象的封装，那么我们就可以使用构建者模式，将该对象的构建交给它来处理，我们使用的时候找他要一个对象就可以了。\n\n假如现在有个User类如下/**\n * @Author：小球某\n * @Date：2021/10/27/17:48\n */\n@Data\npublic class User &#123;\n\n    private String name;\n    private int age;\n    private String sex;\n    private String phone;\n    private String address;\n\n&#125;    \n\n当我们要构建name字段和age字段时 我们可以这样\npublic User(String name, int age) &#123;\n        this.name = name;\n        this.age = age;\n&#125;\n\n同理当需要构建 name字段 age字段  sex字段时\npublic User(String name, int age, String sex) &#123;\n        this.name = name;\n        this.age = age;\n        this.sex = sex;\n&#125;\n\n当我们每次需要构配不同对象时，就要为这些字段生成不同的构造函数，如此一来 我们的构造函数就特别多\n并且阅读性也特别的不好。\n当然还有一种解决办法 就是生成 get set方法   public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n\n    public void setSex(String sex) &#123;\n        this.sex = sex;\n    &#125;\n\n    public void setPhone(String phone) &#123;\n        this.phone = phone;\n    &#125;\n\n    public void setAddress(String address) &#123;\n        this.address = address;\n    &#125;\n\n写的时候这样就可以了\npublic static void main(String[] args) &#123;\n      User user=new User();\n      user.setName(&quot;小球某&quot;);\n      user.setAge(20);\n      user.setSex(&quot;男&quot;);\n&#125;\n\n这样一来就痛苦的是我们程序员了 这个时候构建者就来了\n首先来个静态内部类 字段和User类保持一致/**\n     * 内部类\n     */\n    public static class builder&#123;\n    \n        private String name;\n        private int age;\n        private String sex;\n        private String phone;\n        private String address;\n\n    &#125;\n\n提供构建各个字段的方法     public builder name(String name)&#123;\n         this.name=name;\n         return this;\n     &#125;\n\n     public builder age(int age)&#123;\n         this.age=age;\n         return this;\n     &#125;\n\n     public builder sex(String sex)&#123;\n         this.sex=sex;\n         return this;\n     &#125;\n\n     public builder phone(String phone)&#123;\n         this.phone=phone;\n         return this;\n     &#125;\n\n     public builder address(String address)&#123;\n         this.address=address;\n         return this;\n     &#125;\n\n最后提供构建build方法 同时在User提供构造函数public User build()&#123;\n   return new User(this);\n&#125;\n\npublic User(builder builder)&#123;\n        this.name= builder.name;\n        this.age= builder.age;\n        this.sex= builder.sex;\n        this.phone= builder.phone;\n        this.address= builder.address;\n &#125;\n\n完整代码/**\n * @Author：小球某\n * @Date：2021/10/27/17:48\n */\n@Data\npublic class User &#123;\n\n    private String name;\n    private int age;\n    private String sex;\n    private String phone;\n    private String address;\n\n\n    public User() &#123;\n    &#125;\n\n    public User(builder builder)&#123;\n        this.name= builder.name;\n        this.age= builder.age;\n        this.sex= builder.sex;\n        this.phone= builder.phone;\n        this.address= builder.address;\n    &#125;\n\n    /**\n     * 内部类\n     */\n    public static class builder&#123;\n    \n        private String name;\n        private int age;\n        private String sex;\n        private String phone;\n        private String address;\n\n        public builder name(String name)&#123;\n            this.name=name;\n            return this;\n        &#125;\n\n        public builder age(int age)&#123;\n            this.age=age;\n            return this;\n        &#125;\n\n        public builder sex(String sex)&#123;\n            this.sex=sex;\n            return this;\n        &#125;\n\n        public builder phone(String phone)&#123;\n            this.phone=phone;\n            return this;\n        &#125;\n\n        public builder address(String address)&#123;\n            this.address=address;\n            return this;\n        &#125;\n\n        public User build()&#123;\n            return new User(this);\n        &#125;\n\n    &#125;\n&#125;\n\n用法public static void main(String[] args) &#123;\n        User user1 = new User.builder().name(&quot;小球某&quot;).age(20).build();\n        User user2 = new User.builder().name(&quot;小球某&quot;).age(20).sex(&quot;男&quot;).build();\n        System.out.println(user1);\n        System.out.println(user2);\n&#125;\n\n运行结果如下：\nUser(name=小球某, age=20, sex=null, phone=null, address=null)\nUser(name=小球某, age=20, sex=男, phone=null, address=null)\n\n终极方法：lombok的Builder注解@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User &#123;\n\n    private String name;\n    private int age;\n    private String sex;\n    private String phone;\n    private String address;\n    \n&#125;\n\n用法 public static void main(String[] args) &#123;\n        User user = User.builder().name(&quot;小球某&quot;).age(20).sex(&quot;男&quot;).build();\n        System.out.println(user);\n &#125;\n\n运行结果如下：\nUser(name=小球某, age=20, sex=男, phone=null, address=null)\n\n","tags":["设计模式"]},{"title":"简单实现单点登录","url":"/2021/10/31/SSO-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/","content":"什么是单点登陆 ？\n用简单的话来讲就是 多个系统  一处登陆 处处登陆\n创建项目maven项目\n认证中心\n服务一\n服务二\n\n\n所有模块引入以下依赖\n &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--thymeleaf--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--redis缓存引入 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--lombok--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;1.16.20&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!--fastjson--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;\n            &lt;version&gt;1.2.41&lt;/version&gt;\n        &lt;/dependency&gt;\n &lt;/dependencies&gt;\n\n认证中心配置如下：\n# 应用名称\nspring.application.name=attestation\nserver.port=8000\n\n# Redis服务器地址\nspring.redis.host=127.0.0.1\n# Redis服务器连接端口\nspring.redis.port=6379\n\nclient1配置如下：\n# 应用名称\nspring.application.name=client1\nserver.port=8100\n\n# Redis服务器地址\nspring.redis.host=127.0.0.1\n# Redis服务器连接端口\nspring.redis.port=6379\n\nclient2配置如下：\n# 应用名称\nspring.application.name=client2\nserver.port=8200\n\n# Redis服务器地址\nspring.redis.host=127.0.0.1\n# Redis服务器连接端口\nspring.redis.port=6379\n\n\n为了演示不同域名之间的登录 修改本地hosts文件（文件目录在C:\\Windows\\System32\\drivers\\etc）\n127.0.0.1 attestation.com\n\n127.0.0.1 client1\n\n127.0.0.1 client2\n\n在client1中  编写认证成功后才能访问的页面\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;SSO-服务一 认证成功&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n在client1编写一个简单的Controller\n/**\n * @Author：小球某\n * @Date：2021/10/31/0:03\n */\n@Controller\npublic class indexnController &#123;\n\n    @GetMapping(&quot;list&quot;)\n    public String list()&#123;\n        return &quot;list&quot;;\n    &#125;\n\n&#125;\n\n通过浏览器 访问：http://client1:8100/list  结果如下\n\n这个时候就要编写我们的认证逻辑 ，需要判断是否登录。\n正常通过session来判断用户是否登录 ，登录正常访问，未登录就重定向到我们的认证中心去。\n编写认证中心 登录页面和Controller&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;SSO-认证中心&lt;/h1&gt;\n&lt;form method=&quot;post&quot; action=&quot;&quot;&gt;\n    账号：&lt;input name=&quot;userName&quot; type=&quot;text&quot;&gt;&lt;br&gt;\n    密码：&lt;input name=&quot;password&quot; type=&quot;text&quot;&gt;&lt;br&gt;\n    登陆 &lt;input type=&quot;submit&quot;&gt;\n    &lt;input type=&quot;hidden&quot; name=&quot;url&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n@Controller\npublic class LoginController &#123;\n\n    /**\n     * 跳转到登录视图\n     * @return\n     */\n    @GetMapping(&quot;login.html&quot;)\n    public String loginPage()&#123;\n        return &quot;login&quot;;\n    &#125;\n\n    /**\n     * 处理登录逻辑\n     * @param user\n     * @return\n     */\n    @PostMapping(&quot;doLogin&quot;)\n    public String dolgoin(User user)&#123;\n        return null;\n    &#125;\n\n&#125;\n\n  @Data\n  public class User implements Serializable&#123;\n     private String userName;\n     private String password;\n  &#125;\n\nclient1代码 改动如下：\n    @GetMapping(&quot;list&quot;)\n    public String list(HttpSession session)&#123;\n        if(session.getAttribute(&quot;loginUser&quot;)==null)\n            return &quot;redirect:http://attestation.com:8000/login.html&quot;;\n        return &quot;list&quot;;\n    &#125;\n\n请求流程变成这样：\nclient1:8100/list —-》attestation.com:8000/login.html  —-》登录认证后  —-》attestation.com:8000/doLogin\n那么问题来了 当认证中心的dolgoin请求处理完成以后 要跳转到那里去呢？\n正常应该是跳转到client1:8100/list 中去 那么怎么才能正常跳转。\n可以在client1中跳转login.html请求的时候携带一个redirect_ur1参数，login.html请求接收这个URL，并将这个参数隐藏在前端， 提交dolgoin请求的时候传递这个URL即可。client1中代码改动如下：\n @GetMapping(&quot;list&quot;)\n    public String list(HttpSession session)&#123;\n        if(session.getAttribute(&quot;loginUser&quot;)==null)\n            return &quot;redirect:http://attestation.com:8000/login.html?redirect_ur1=http://client1:8100/list&quot;;\n        return &quot;list&quot;;\n    &#125;\n\nlogin请求改动如下：\n    @GetMapping(&quot;login.html&quot;)\n    public String loginPage(@RequestParam(&quot;redirect_ur1&quot;) String url, Model model)&#123;\n        model.addAttribute(&quot;url&quot;,url);\n        return &quot;login&quot;;\n    &#125;\n\n页面改动如下：\n&lt;form method=&quot;post&quot; action=&quot;doLogin&quot;&gt;\n    账号：&lt;input name=&quot;userName&quot; type=&quot;text&quot;&gt;&lt;br&gt;\n    密码：&lt;input name=&quot;password&quot; type=&quot;text&quot;&gt;&lt;br&gt;\n    &lt;input type=&quot;hidden&quot; name=&quot;url&quot; th:value=&quot;$&#123;url&#125;&quot;&gt;\n    登陆 &lt;input type=&quot;submit&quot;&gt;\n&lt;/form&gt;\n\n为了方便就将URL这个参数添加到User中去\n  @Data\n  public class User implements Serializable&#123;\n     private String userName;\n     private String password;\n     private String url;\n  &#125;\n\n这个时候dolgoin请求就可以正常的跳转回去了\n    @PostMapping(&quot;doLogin&quot;)\n    public String dolgoin(User user, HttpSession session)&#123;\n        session.setAttribute(&quot;loginUser&quot;,user);\n        return &quot;redirect:&quot;+user.getUrl();\n    &#125;\n\n改动完代码以后 并登陆后运行结果如下：\n\n明明登陆了 为什么还是会跳转到认证中心呢原因如下：在list请求中我们是通过session来判断是否登录， 虽然在认证中心登录， 但认证中心存的session\n client1是取不到  所以就会重新跳转到认证中心去。\n这个时候我们可以换一个思路，将认证中心存放的session 放入Redis中并将存入时放的key 在重定向的时候携带给client1 ， client1 中接收这个key来判断即可。认证中心代码变化如下：    @Resource\n    private RedisTemplate redisTemplate;\n\n    @PostMapping(&quot;doLogin&quot;)\n    public String dolgoin(User user)&#123;\n        String token= UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);\n        redisTemplate.opsForValue().set(token,JSON.toJSONString(user),30, TimeUnit.MINUTES);\n        return &quot;redirect:&quot;+user.getUrl()+&quot;?token=&quot;+token;\n    &#125;\n\nclient1代码变化如下：    @Resource\n    private RedisTemplate redisTemplate;\n\n    @GetMapping(&quot;list&quot;)\n    public String list(@RequestParam(value = &quot;token&quot;,required = false) String token, HttpSession session)&#123;\n        if(!StringUtils.isEmpty(token))&#123;\n            String json = (String) redisTemplate.opsForValue().get(token);\n            User loginUser = JSON.parseObject(json, User.class);\n            if(loginUser!=null)\n                session.setAttribute(&quot;loginUser&quot;,loginUser);\n        &#125;\n        if(session.getAttribute(&quot;loginUser&quot;)==null)\n            return &quot;redirect:http://attestation.com:8000/login.html?redirect_ur1=http://client1:8100/list&quot;;\n        return &quot;list&quot;;\n    &#125;\n\n为了看到认证后的效果 修改client1中HTML代码\n&lt;body&gt;\n&lt;h1&gt;SSO-服务一 认证成功&lt;/h1&gt;\n&lt;h1&gt;登录信息如下&lt;/h1&gt;\n&lt;h1 th:text=&quot;$&#123;session.loginUser==null?&#39;账号：未登录&#39;:&#39;账号：&#39;+session.loginUser.userName&#125;&quot;&gt;&lt;/h1&gt;\n&lt;h1 th:text=&quot;$&#123;session.loginUser==null?&#39;密码：未登录&#39;:&#39;密码：&#39;+session.loginUser.password&#125;&quot;&gt;&lt;/h1&gt;\n&lt;/body&gt;\n\n运行结果如下：访问http://client1:8100/list \n\n正常跳转到认证中心 登录后 正常显示\n\n这个时候我们把client1代码复制给client2，并修改重定向redirect_ur1参数变成client2的地址\n@GetMapping(&quot;list&quot;)\n    public String list(@RequestParam(value = &quot;token&quot;,required = false) String token, HttpSession session)&#123;\n        if(!StringUtils.isEmpty(token))&#123;\n            String json = (String) redisTemplate.opsForValue().get(token);\n            User loginUser = JSON.parseObject(json, User.class);\n            if(loginUser!=null)\n                session.setAttribute(&quot;loginUser&quot;,loginUser);\n        &#125;\n        if(session.getAttribute(&quot;loginUser&quot;)==null)\n            return &quot;redirect:http://attestation.com:8000/login.html?redirect_ur1=http://client2:8200/list&quot;;\n        return &quot;list&quot;;\n    &#125;\n\n 启动起来 访问：http://client2:8200/list\n\n为什么是还是会跳转到认证中心去 在client1中不是登录了吗分析代码：首先会判断token 我们没有token 然后会判断session 这个时候也没有 所以会重定向到认证中心去 \n这个时候我们可以在dolgoin请求登录后，在存入Redis的同时，在Cookie中也同时保存一份信息，并且在loginPage请求中判断是否有Cookie 如果有则证明有人登录过 直接跳转回去即可。认证中心代码变化如下：\n   /**\n     * 处理登录请求\n     * @param user\n     * @param response\n     * @return\n     */\n    @PostMapping(&quot;doLogin&quot;)\n    public String dolgoin(User user, HttpServletResponse response)&#123;\n        String token= UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);\n        redisTemplate.opsForValue().set(token,JSON.toJSONString(user),30, TimeUnit.MINUTES);\n        Cookie cookie = new Cookie(&quot;sso_token&quot;, token);\n        response.addCookie(cookie);\n        return &quot;redirect:&quot;+user.getUrl()+&quot;?token=&quot;+token;\n    &#125;\n\n    /**\n     * 跳转到登录视图\n     * @param url\n     * @param model \n     * @param token  \n     * @return\n     */\n    @GetMapping(&quot;login.html&quot;)\n    public String loginPage(@RequestParam(&quot;redirect_ur1&quot;) String url, Model model,\n                            @CookieValue(value = &quot;sso_token&quot;,required = false) String token)&#123;\n        if(!StringUtils.isEmpty(token))&#123;\n            return &quot;redirect:&quot;+url+&quot;?token=&quot;+token;\n        &#125;\n        model.addAttribute(&quot;url&quot;,url);\n        return &quot;login&quot;;\n    &#125;\n\n最后运行client2 访问：http://client2:8200/list\n\n 代码地址\n","tags":["java"]},{"title":"生产者/消费者模式","url":"/2021/11/05/%E7%94%9F%E6%88%90%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/","content":"一步一步走进生产消费者首我们创建一个普通java工程\n定义一个实现类 实现生产方法和消费方法 \n为了简单 我们就用使用普通的synchronized锁和  boolean变量来判断是否生产消费 \n/**\n * @Author：小球某\n * @Date：2021/11/06/0:01\n */\npublic class Realization &#123;\n    private Object lock;//锁\n    private boolean sign=true;//true生产 false消费 看好这个状态位 下面很重要\n\n    public Realization(Object lock) &#123;\n        this.lock = lock;\n    &#125;\n&#125;\n\n编写生产方法   /**\n     *生产方法\n     */\n    public void producer()&#123;\n        synchronized (lock)&#123;\n            try&#123;\n                if(!sign)\n                    lock.wait();\n                System.out.println(Thread.currentThread().getName()+&quot; 生产&quot;);\n                sign=false;\n                lock.notify();\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n编写消费者方法   /**\n     * 消费方法\n     */\n    public void consumer()&#123;\n        synchronized (lock)&#123;\n            try&#123;\n                if(sign)\n                    lock.wait();\n                System.out.println(Thread.currentThread().getName()+&quot; 消费&quot;);\n                sign=true;\n                lock.notify();\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n编写生产者/**\n * @Author：小球某\n * @Date：2021/11/06/00:16\n * 生产者\n */\npublic class Producer implements Runnable&#123;\n    private Realization realization;\n    \n    public Producer(Realization realization) &#123;\n        this.realization = realization;\n    &#125;\n    \n    @Override\n    public void run() &#123;\n        while (true)&#123;\n            realization.producer();\n        &#125;\n    &#125;\n&#125;\n\n编写消费者/**\n * @Author：小球某\n * @Date：2021/11/06/00:19\n * 消费者\n */\npublic class Consumer implements Runnable&#123;\n    private Realization realization;\n\n    public Consumer(Realization realization) &#123;\n        this.realization = realization;\n    &#125;\n    \n    @Override\n    public void run() &#123;\n       while (true)&#123;\n           realization.consumer();\n       &#125;   \n    &#125;\n&#125;\n\n最后编写Main测试public static void main(String[] args) &#123;\n\n    Realization realization = new Realization(new Object());\n\n    Producer producer = new Producer(realization);\n    Consumer consumer = new Consumer(realization);\n\n    new Thread(producer,&quot;生产者&quot;).start();\n    new Thread(consumer,&quot;消费者&quot;).start();\n&#125;\n\n运行结果如下：\n\n运行结果也不错 生产一个消费多个 没有什么问题\n但我们实际使用生产者消费者模式的时候一般是会多个生产者和消费者\n这个我们开启多个生产者和多个消费者 试一试我们的代码\npublic static void main(String[] args) &#123;\n\n        Realization realization = new Realization(new Object());\n\n        Producer producer = new Producer(realization);\n        Consumer consumer = new Consumer(realization);\n\n        new Thread(producer,&quot;生产者-1号&quot;).start();\n        new Thread(producer,&quot;生产者-2号&quot;).start();\n        new Thread(consumer,&quot;消费者-1号&quot;).start();\n        new Thread(consumer,&quot;消费者-2号&quot;).start();\n    &#125;\n\n运行结果如下：\n\n为什么会这种 生产一个 消费两次的情况呢？\n来看核心代码：\n1   if(sign)\n2       lock.wait();\n3   System.out.println(Thread.currentThread().getName()+&quot; 消费&quot;);\n4   sign=true;\n5   lock.notify();\n\n上面的boolean标记是默认是true，所以是要先生产 后消费\n现在我们来模拟 刚刚发送的情况的这种情况生产者:t1 t2 消费者：t3 t41步： t3得到调度 判断If  为  true  t3休眠  （休眠：t3   状态位：true）\n2步：恰巧t4也得到调度 和t3一样休眠 （休眠：t3  t4   状态位：true）\n3步：t1得到调度 首先判断if 要生产一个消息 然后改变状态位 用notify 唤醒了t3  (休眠：t4   状态位：false)\n4步：t3得到调度 从第2行代码醒来的t3 会接着往下执行3 4行代码 并改变状态位  唤醒的人是t4 (状态位：true)\n5步：t4得到调度  从第2行代码醒来的t4   会接着往下执行3 4行代码 改变状态位 唤醒\n其实在第5步 t4唤醒 往下执行的时候就错误了 状态位都是true \n问题出的地方就是 不管是生产者还是消费者 ，每次唤醒的时候 ，都要回头在看一下状态位是否正确 ，正确则继续执行 否则就继续休眠。\n解决办法：用while来判断状态位修改后的生产者方法   /**\n     *生产方法\n     */\n    public void producer()&#123;\n        synchronized (lock)&#123;\n            try&#123;\n                while(!sign)\n                    lock.wait();\n                System.out.println(Thread.currentThread().getName()+&quot; 生产&quot;);\n                sign=false;\n                lock.notify();\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n修改后的消费者方法   /**\n     * 消费方法\n     */\n    public void consumer()&#123;\n        synchronized (lock)&#123;\n            try&#123;\n                while(sign)\n                    lock.wait();\n                System.out.println(Thread.currentThread().getName()+&quot; 消费&quot;);\n                sign=true;\n                lock.notify();\n            &#125;catch (InterruptedException e)&#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;\n\n修改完代码后 我们继续运行：\n\n可以看到程序是没有停止了 但为什么会没有运行下去呢？\n来看核心代码：\nlock.notify();\n\n现在我们来模拟 刚刚发送的情况的这种情况生产者:t1 t2 消费者：t3 t41步：t3得到调度 判断状态位 休眠  （休眠：t3）\n2步：t4得到调度  判断状态位 休眠   (休眠：t3  t4）\n3步：t1得到调度 判断状态位  生产 唤醒 t3   (休眠：t4)\n4步：t1又被调度  判断状态位 休眠   (休眠：t4  t1)\n5步：t2得到调度  判断状态位 休眠   (休眠：t4  t1  t2)\n6步：t3得到调度  判断状态位  消费  唤醒t4  (休眠：t1  t2)\n7步：t3又被调度  判断状态位  休眠  （休眠：t1 t2  t3）\n8步：只有t4存活 得到调度 判断状态位 休眠  （休眠：t1  t2 t3  t4）\n至此所以线程全部到了休眠状态 也没有其他线程会唤醒\n解决办法 使用lock.notifyAll();总结：在多生产者多线程的情况下，判断状态位的时候需要使用while判断 ，要不然可能会造成 一次生产多次消费，或者一次消费多次生产的情况，唤醒线程使用notifyAll() ,要不然可能会造成全部进入休眠状态 导致程序无法运行。当然这只是生产者 消费者的一种实现方法 还有其他多种实现方法。 代码地址\n","tags":["设计模式"]},{"title":"浅谈java三兄弟","url":"/2021/11/09/java%E4%B8%89%E5%85%84%E5%BC%9F/","content":"java对象模型 Java内存模型 JVM内存结构这三兄弟不要傻傻分不清\njava对象模型：就是咱们经常在代码中new的对象 对象保存在堆中，而我们在对对象进行操作时，其实操作的是对象的引用。\nJava对象包含三个部分一个Java对象可以分为三部分存储在内存中，分别是：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。\n\n\n对象头：默认存储 (哈希值(HashCode )、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳)等信息。\n实例数据：它是对象真正存储的有效信息,包括程序代码中定义的各种类型的字段。\n对齐填充：虚拟机要求对象起始地址是8字节的整数倍。填充数据不是必须存在的,只是为了字节对齐。\n\njava内存模型：Java内存模型也就是常说的JMM,是一组规范,需要各个JVM的实现来遵守JMM规范,以便于开发者可以利用这些规范,更方便地开发多线程程序。\n为什么会有这组规范？\n在C语言中不存在内存模型这样的概念，所以很多行为都是依赖处理器本身的，而不同的处理器之间对synchronized的理解不一样 会导致处理的结果也是不一样的。在一个处理上是一个结果，另一个处理上又是其他结果，也无法保证并发的安全。由于我们java是跨平台，所以迫切的需要一种规范来 让多线程运行的结果达到预期的结果。如果没有这样的一个JMM内存模型来规范,那么很可能经过了不同JVM的不同规则的重排序之后,导致不同的虚拟机上运行的结果不一样,那是很大的问题。\n在这些规范当中 最重要的三点就是：原子性、可见性、重排序\n原子性：用通俗的话来讲 操作不可中断 ，即使是在多线程情况下也不可中断，要不然执行成功 ,要不然不执行 。\n在java中的原子操作有 ：\n1.除了long和double之外的基本类型 赋值操作\n2.所有引用的赋值操作\n3.原子包下的原子类的操作\n可见性：保证多线程之间的修改变量 其他线程能够感知到。\nJMM有规定:\n1.所有的变量都存储在主内存中，同时每个线程有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝2.线程不能直接读写主内存中的变量，而是只能操作自己工作内存中的变量,然后再同步到主内存中3.主内存是多个线程共享的，但线程间不共享工作内存，如果线程间需要通信，必须借助主内存中转来完成所有的共享变量存在于主内存中，每个线程有自己的本地内存,而且线程读写共享数据，也是通过本地内存交换的，所以才导致了可见性问题。\n\n那么JMM怎么保证可见性呢：\n当我们的变量在Synchronize中或者被Volatile修饰时\n\n变量的写操作会立即刷到主内存中，确保其他线程可以获取到最新的值。\n变量的读操作会直接读取主内存中的值。\n\n当然Volatile只能保证变量的可见性 并不能像Synchronize还能保证原子性，在这里就不详细展开了。\n重排序：就是禁止重排序，那为什么会有重排序？：\n其实说到底都是源于对性能的优化，CPU运行效率 相比缓存、内存、硬盘IO之间效率有着指数级的差别，CPU作为系统的宝贵资源，那么如何更好的优化和利用这个资源就能提升整个计算机系统的性能\n从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序\n\n指令重排序的原则（as-if-serial语义）编译器和处理指令也并非什么场景都会进行指令重排序的优化，而是会遵循一定的原则，只有在它们认为重排序后不会对程序结果产生影响的时候才会进行重排序的优化，如果重排序会改变程序的结果，那这样的性能优化显然是没有意义的。而遵守as-if-serial 语义规则就是重排序的一个原则，as-if-serial 的意思是说，可以允许编译器和处理器进行重排序，但是有一个条件，就是不管怎么重排序都不能改变单线程执行程序的结果。\n1  a=1; //语句1\n2  b=2; //语句2\n3  a=a+3;\n\n对于上面代码的指令如下：\n1.Load a\n2.Set to 1\n3.Store a\n4.Load b\n5.Set to 2\n6.Store b\n7.Load a\n8.Set to 4\n9.Store a\n\nCPU会认为语句1和语句2没有关系 重排序后变成这样\n1  b=2;\n2  a=1;\n3  a=a+3;\n\n对于的指令如下：\n1.Load b\n2.Set to 2\n3.Store b\n4.Load a\n5.Set to 1\n6.Set to 4\n7.Store a\n\n经过重排序后将9条指令优化成7条，那么重排序会优化我们的程序 那么为什么jmm还会有禁止重排序呢？\n看下面代码\n  private static int value;\n     private static boolean flag;\n \n     public static  void  init()&#123;\n         value=1;     //语句1\n         flag=true;  //语句2\n     &#125;\n \n     public static void getValue()&#123;\n         if(flag)&#123;\n             System.out.println(value);\n         &#125;\n     &#125;\n\n在单线程情况下 如果代码没有发送重排序 那么先运行init() 再运行 getValue()方法  打印的结果 肯定是1\n当cpu认为语句1和语句2没有关系时 进行了重排序可能会变成这样\n   public static  void  init()&#123;\n         flag=true;  //语句2\n         value=1;    //语句1\n     &#125;\n\n这个时候两个线程分别调用 init()和getValue()方法，那么就有可能出现这种情况\n线程一 执行 init() 当执行到   flag=true; 时  \n线程二 马上执行完 getValue()方法 然后会打印0\n然后线程一在把  value=1; 执行完毕。\n这样就是导致和我们预期的结果不一致 ,我们预期的结果是调用  getValue()方法打印1出来 。\n所以在复杂的多线程环境下，编译器和处理器是根本无法通过语义分析来知道代码指令的依赖关系的，所以这个问题只交给能写代码的人才能清楚的知道，这个时候编写代码的人就需要通过一种方式显示的告诉编译器和处理器哪些地方是存在逻辑依赖的，这些地方不能进行重排序。\n使用Volatile就能保证禁止重排序JVM内存结构Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。\n每个区域都有各自的作用。\n\n上面图中 绿色区域都是线程共享的  黄色区域都是线程私有的。\n程序计数器：是记住下一条jvm指令的执行地址 当执行的是Native方法是为0  ,是线程私有 和其他区不同的是 程序计数器永远不会内存溢出。\njava栈：每当启动一个新线程时，Java虚拟机都会为它分配一个Java栈。Java栈以帧为单位保存线程的运行状态。虚拟机只会直接对Java栈执行两种操作：以帧为单位的压栈和出栈。\n　　某个线程正在执行的方法被称为该线程的当前方法，当前方法使用的栈帧称为当前帧，当前方法所属的类称为当前类，当前类的常量池称为当前常量池。在线程执行一个方法时，它会跟踪当前类和当前常量池。此外，当虚拟机遇到栈内操作指令时，它对当前帧内数据执行操作。\n　　每当线程调用一个Java方法时，虚拟机都会在该线程的Java栈中压入一个新帧。而这个新帧自然就成为了当前帧。在执行这个方法时，它使用这个帧来存储参数、局部变量、中间运算结果等数据。\n　　Java方法可以以两种方式完成。一种通过return返回的，称为正常返回；一种是通过抛出异常而异常终止的。不管以哪种方式返回，虚拟机都会将当前帧弹出Java栈然后释放掉，这样上一个方法的帧就成为当前帧了。\n　　Java帧上的所有数据都是此线程私有的。任何线程都不能访问另一个线程的栈数据，因此我们不需要考虑多线程情况下栈数据的访问同步问题。当一个线程调用一个方法时，方法的的局部变量保存在调用线程Java栈的帧中。只有一个线程能总是访问那些局部变量，即调用方法的线程。\n本地方法栈：Java 虚拟机的实现可以使用传统的堆栈，通俗地称为“C 堆栈”，以支持native方法（用 Java 编程语言以外的语言编写的方法）。本机方法堆栈也可以由 Java 虚拟机指令集的解释器实现使用，例如 C 语言。无法加载native 方法且本身不依赖常规堆栈的Java 虚拟机实现不需要提供本机方法堆栈. 如果提供，则通常在创建每个线程时为每个线程分配本机方法堆栈。\n堆区：Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的堆。堆是运行时数据区，从中分配所有类实例和数组的内存，线程共享的。\n方法区：Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区。方法区类似于传统语言的编译代码存储区，或类似于操作系统进程中的“文本”段。它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化和接口初始化中使用的特殊方法。\n1.6在堆区中使用 永久代实现 ，1.8使用堆外内存 元空间实现。\n使用元空间的好处是\n1.字符串常量池存在永久代中,容易出现性能问题和内存溢出2.类和方法的信息大小难易确定,给永久代的大小指定带来困难3.永久代会为GC带来不必要的复杂性\n","tags":["java"]},{"title":"单例的五种实现","url":"/2021/11/16/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"设计模式之单例模式什么是单例设计模式？\n单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。\n具体实现\n需要：\n（1）将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。\n（2）在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型。\n（3）定义一个静态方法返回这个唯一对象。\n饿汉式：顾名思义很饿 所以在类加载的时候就加载了对象\n/**\n * @Author：小球某\n * @Date：2021/11/16/23:47\n * 饿汉式\n */\npublic class HungrySingleton &#123;\n    private HungrySingleton()&#123;&#125;;\n\n    private static final HungrySingleton SINGLETON=new HungrySingleton();\n\n    public static HungrySingleton getInstance()&#123;\n       return SINGLETON;\n    &#125;\n&#125;\n\n饿汉式优缺点：优点：实现起来简单，没有多线程同步问题。\n缺点：当类SingletonTest被加载的时候，会初始化static的instance，静态变量被创建并分配内存空间，从这以后，这个static的instance对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。\n懒汉式:很懒只有要用时候才会去加载\npackage com.xqm;\n\n/**\n * @Author：小球某\n * @Date：2021/11/16/23:56\n * 懒汉式\n */\npublic class LazySingleton &#123;\n    private LazySingleton()&#123;&#125;;\n    \n    private static LazySingleton SINGLETEN;\n    \n    public static LazySingleton getInstance()&#123;\n        if(SINGLETEN==null)&#123;   //语句1\n            SINGLETEN=new LazySingleton(); //语句2\n        &#125;\n        return SINGLETEN;\n    &#125;\n\n&#125;\n\n这种写法在单线程情况下这种下是没有安全问题的。\n多线程情况下  当线程一和线程二 同时来到语句1 然后判断为空 分别会执行语句2 把对象创建多次。\n那么为了线程安全 我们这样修改代码\n public static synchronized LazySingleton getInstance()&#123;\n        if(SINGLETEN==null)&#123;\n            SINGLETEN=new LazySingleton();\n        &#125;\n        return SINGLETEN;\n    &#125;\n\n这样修改后虽然没有多线程下没有问题 ，但是直接把synchronized套在方法上 ，让方法的执行效率很低，每一次只能让一个线程进来 即使是对象已经不为空创建了。\n那么为了即保证线程安全又要保证执行效率 就要缩小synchronized的粒度 不能直接使用在方法上。\n public static  LazySingleton getInstance()&#123;\n        if(SINGLETEN==null)&#123;//语句1\n            synchronized (LazySingleton.class)&#123;//语句2\n                SINGLETEN=new LazySingleton();\n            &#125;\n        &#125;\n        return SINGLETEN;\n    &#125;\n\n把粒度缩小到创建对象上 那么这样写有没有问题呢？\n当第一次执行的时候 ，线程一和线程二同时来到语句1，判断为空执行语句2的时候 ，虽然加了synchronized\n但也只是让同一时刻 ，有一个线程创建对象而已，线程一创建完成以后 释放锁  线程二拿到锁 继续创建对象。\n那么问题就出现在线程二语句2 的时候，不能直接创建 而应该再次判断对象是否为空。\n public static  LazySingleton getInstance()&#123;\n        if(SINGLETEN==null)&#123;//语句1\n            synchronized (LazySingleton.class)&#123;//语句2\n                if(SINGLETEN==null)&#123;\n                    SINGLETEN=new LazySingleton();\n                &#125;\n            &#125;\n        &#125;\n        return SINGLETEN;\n    &#125;\n\n这样的写法就是大名鼎鼎的DCL双检查锁机制  那么这样写就真的没有问题的了吗？\n在上一篇java三兄弟中讲了JMM。\n\n创建对象的过程如上图，当发生重排序后 会颠倒 2 3的执行顺序。\n线程一  在创建对象的时候  发生了重排序  执行了3  还没来得及执行2\n线程二  看到指向的内存地址，就会判断不为空，从而直接返回。   其实这个时候对象是没有完成初始化的，当外界使用对象的时候， 所以就会发生错误。\n为了解决发生重排序问题 要使用volatile修饰  最终代码如下public class LazySingleton &#123;\n    private LazySingleton()&#123;&#125;;\n\n    private static volatile LazySingleton SINGLETEN;\n\n    public static  LazySingleton getInstance()&#123;\n        if(SINGLETEN==null)&#123;\n            synchronized (LazySingleton.class)&#123;\n                if(SINGLETEN==null)&#123;\n                    SINGLETEN=new LazySingleton();\n                &#125;\n            &#125;\n        &#125;\n        return SINGLETEN;\n    &#125;\n\n&#125;\n\n懒汉式优缺点：优点：实现延迟加载 不使用的情况下，能够节约一定的内存。\n缺点：实现起来比较复杂，得考虑多线程情况下发生的问题。\n静态内存类利用加载一个类时，其内部类不会同时被加载。当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时，才会触发加载。\n/**\n * @Author：球某\n * @Date：2021/11/17/1:44\n * 静态内部类\n */\npublic class StaticInnerClassSingleton &#123;\n\n    private StaticInnerClassSingleton()&#123;&#125;\n\n    private static class InnerClass&#123;\n       private static StaticInnerClassSingleton singleton=new StaticInnerClassSingleton();\n    &#125;\n\n    public static StaticInnerClassSingleton getInstance()&#123;\n        return InnerClass.singleton;\n    &#125;\n\n&#125;\n\n\n这种写法在多线程情况下就没有安全问题吗？\n从上图可以看出， 当两个线程同时加载时 JVM会保证只能有一个线程去加载，即线程0在加载时内部发生了重排序，由于加了锁，整个重排序对线程1是不可见的 ，线程1只能等待 线程0加载完成。\n所以就不会出现上面这种情况，一个线程发生重排序 还没执行完2的时候 ，被另一个看到已经有指向的地址，从而来判断不为空 直接返回 然后在外界使用还没有初始化完成的对象。 \n静态内部类优缺点：优点：也实现延迟加载 也能保证线程的安全。\n缺点：实现起来还要额外写一个内部类。\n容器单例法：spring单例Bean也是利用容器实现，我们可以利用ConcurrentHashMap来实现单例\n/**\n * @Author：小球某\n * @Date：2021/11/17/1:54\n */\npublic class ContainerSingleton &#123;\n    private ContainerSingleton()&#123;&#125;;\n\n    private static ConcurrentHashMap&lt;String,ContainerSingleton&gt; map=new ConcurrentHashMap();\n\n    private static String KEY=&quot;singleten&quot;;\n\n    public static ContainerSingleton getInstance()&#123;\n        ContainerSingleton singleten = map.get(KEY);\n        return singleten!=null?singleten:map.computeIfAbsent(KEY,s-&gt; new ContainerSingleton());\n    &#125;\n\n&#125;\n\n通过使用ConcurrentHashMap的computeIfAbsent方法实现，能够实现原子性的操作，从而达到多线程的安全。\n容器单例优缺点：优点：也实现延迟加载 也能保证线程的安全。\n缺点：还需要额外使用容器来存储对象，浪费了一定的内存。\n枚举单例：利用枚举来实现单例\n/**\n * @Author：球某\n * @Date：2021/11/17/1:59\n * 枚举法\n */\npublic enum EnumSingleton  &#123;\n    INSTANCE;\n    private Object data;\n\n    private EnumSingleton()&#123;\n        data=new Object();\n    &#125;\n\n    public static EnumSingleton getInstance()&#123;\n        return INSTANCE;\n    &#125;\n\n    public Object getData()&#123;\n        return data;\n    &#125;\n\n&#125;\n\nJava规范字规定，每个枚举类型及其定义的枚举变量在JVM中都是唯一的，因此在枚举类型的序列化和反序列化上，Java做了特殊的规定。在序列化的时候Java仅仅是将枚举对象的name属性输到结果中，反序列化的时候则是通过java.lang.Enum的valueOf()方法来根据名字查找枚举对象。也就是说，序列化的时候只将DATASOURCE这个名称输出，反序列化的时候再通过这个名称，查找对应的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。\n枚举单例优缺点：优点：写法简单高效，天然的防止反序列化和反射。\n缺点：在我看来没有缺点。\n总结：各种写法都有自己的优缺点，面试问的比较多就是DCL双检查锁机制  最实用的也是就是枚举，当然关于单例的序列化和反射破坏 留到下一篇来讲。代码地址\n","tags":["设计模式"]},{"title":"破坏单例","url":"/2021/11/25/%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B/","content":"破坏单例怎么破坏单例呢？\n可以从反序列化和反射来破坏。\n对于上一篇讲的五种写法，我们分别来破坏，看看是个什么情况。\n饿汉式：反序列化攻击：饿汉式public static void main(String[] args) throws Exception&#123;\n        HungrySingleton instance = HungrySingleton.getInstance();\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;instance_file&quot;));\n        oos.writeObject(instance);\n\n        File file = new File(&quot;instance_file&quot;);\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));\n        HungrySingleton readObject = (HungrySingleton)ois.readObject();\n\n        System.out.println(instance);\n        System.out.println(readObject);\n        System.out.println(instance==readObject);\n    &#125;\n\n运行结果：\n\n经过了序列化和反序列化之后 ，饿汉式就产生了两个对象 ，很显然这样就违背了单例设计的原则。 \n那么怎么解决反序列化攻击呢？\n在HungrySingleton中编写一个readResolve()方法代码如下\n/**\n * @Author：小球某\n * @Date：2021/11/16/23:47\n * 饿汉式\n */\npublic class HungrySingleton implements Serializable &#123;\n    private HungrySingleton()&#123;&#125;;\n\n    private static final HungrySingleton SINGLETON=new HungrySingleton();\n\n    public static HungrySingleton getInstance()&#123;\n       return SINGLETON;\n    &#125;\n\n    /**\n     * 防止反序列化\n     * @return\n     */\n    private Object readResolve()&#123;\n        return SINGLETON;\n    &#125;\n&#125;\n\n然后重新运行：\n\n为什么我们提供了一个readResolve()方法就能保证安全呢？\n从readObject()方法入手分析。\n\n进到 readObject0方法中\n\n继续进到 readOrdinaryObject(unshared)方法中\n\n继续进到 desc.isInstantiable()方法中\n\nisInstantiable()方法中的注释讲，如果表示的类是可序列化/可外部化的并且可以由序列化运行时实例化，则返回 true  。\n那么2011行代码的 desc.isInstantiable()返回true  ，根据三目运算符，就会执行 desc.newInstance()方法。\n继续进到newInstance()方法\n\n在这里最主要的一句是 cons.newInstance();\n那我们看看 cons是个什么\n\n原是一个构造器，所以cons.newInstance(); 就是用反射创建了一个对象。\n所以在这里也解释了为什么会破坏单例 它是用反射new了个新对象。\n这样一来2009行的 obj对象就不为空。我们继续往readOrdinaryObject()方法往下看\n\n来到2032行，因为obj不为空 所以会执行到 2033行的handles.lookupException(passHandle)方法\n我们先来看 传递的参数passHandle等于什么。\n\n然后继续进到lookupException()方法中去\n\nlookupException()方法中的注释也说得很清楚了， 如果给定的句柄是 NULL_HANDLE，或者没有与句柄关联的 ClassNotFoundException，则返回 null。\n所以2033行中的 handles.lookupException(passHandle) == null 为true 。\n会继续执行2034行的desc.hasReadResolveMethod()方法，继续跟进去。\n\nhasReadResolveMethod方法的注释也说得很明白了，定义了一致的 readResolve 方法，则返回 true。\n因为我们写了一个readResolve 方法，所以整个表达式的结果为true ，进入if。\n执行2036行的Object rep = desc.invokeReadResolve(obj)代码。\n继续进到 invokeReadResolve(obj)方法中\n\ninvokeReadResolve方法的注释说，readResolve 方法并返回结果。\n我们在HungrySingleton中的代码是返回单例对象\n /**\n     * 防止反序列化\n     * @return\n     */\n    private Object readResolve()&#123;\n        return SINGLETON;\n    &#125;\n\n所以在2036行代码中的rep 等于我们的单例对象。\n继续往下看\n\n来到2040行代码， rep是单例对象  obj是反射的对象 自然不会相等 进入if，最终将obj指向单例对象 并返回出去。\n所以这就是为什么写一个readResolve()方法就能防止反序列化攻击了。\n小结：readObject()方法会检查类中有没有readResolve()方法，如果有则调用，这样我们就可以在readResolve()方法中添加我们的逻辑 ，从而达到单例的安全。\n反序列化攻击看完了，我们继续来看反射攻击。\n反射攻击：饿汉式 public static void main(String[] args) throws Exception&#123;\n\n        HungrySingleton instance = HungrySingleton.getInstance();\n\n        Class&lt;HungrySingleton&gt; aClass = HungrySingleton.class;\n        Constructor&lt;HungrySingleton&gt; constructor = aClass.getDeclaredConstructor();\n        constructor.setAccessible(true);\n        HungrySingleton newInstance = constructor.newInstance(null);\n\n        System.out.println(instance);\n        System.out.println(newInstance);\n        System.out.println(instance==newInstance);\n    &#125;\n\n运行结果：\n\n通过反射 打开私有构造器权限，就可以new出新的对象，从而破坏单例。\n那么怎么解决呢？\nprivate HungrySingleton()&#123;\n      if(SINGLETON!=null)\n        throw new RuntimeException(&quot;单例构造器 禁止反射破坏&quot;);\n &#125;;\n\n在私有构造函数中判断，禁止new出对象。\n因为饿汉式是在类加载阶段时候创建的，在反射代码调用时就已经存在，就会抛出异常。\n从而不会new出两次，达到防止反射安全。\n静态内部类：反序列化攻击：静态内部类 public static void main(String[] args) throws Exception&#123;\n\n        StaticInnerClassSingleton instance = StaticInnerClassSingleton.getInstance();\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;instance_file&quot;));\n        oos.writeObject(instance);\n\n        File file = new File(&quot;instance_file&quot;);\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));\n        StaticInnerClassSingleton readObject = (StaticInnerClassSingleton)ois.readObject();\n\n        System.out.println(instance);\n        System.out.println(readObject);\n        System.out.println(instance==readObject);\n    &#125;\n\n结果和上面饿汉式表现一样，会被破坏，需要编写一个readResolve()方法代码，才能反序列化安全。\n/**\n * @Author：球某\n * @Date：2021/11/17/1:44\n * 静态内部类\n */\npublic class StaticInnerClassSingleton implements Serializable &#123;\n\n    private StaticInnerClassSingleton()&#123;&#125;\n\n    private static class InnerClass&#123;\n       private static StaticInnerClassSingleton singleton=new StaticInnerClassSingleton();\n    &#125;\n\n    public static StaticInnerClassSingleton getInstance()&#123;\n        return InnerClass.singleton;\n    &#125;\n\n    /**\n     * 防止反序列化\n     * @return\n     */\n    private Object readResolve()&#123;\n        return InnerClass.singleton;\n    &#125;\n&#125;\n\n反射攻击：静态内部类 public static void main(String[] args) throws Exception&#123;\n\n        StaticInnerClassSingleton instance = StaticInnerClassSingleton.getInstance();\n\n        Class&lt;StaticInnerClassSingleton&gt; aClass = StaticInnerClassSingleton.class;\n        Constructor&lt;StaticInnerClassSingleton&gt; constructor = aClass.getDeclaredConstructor();\n        constructor.setAccessible(true);\n        StaticInnerClassSingleton newInstance = constructor.newInstance(null);\n\n        System.out.println(instance);\n        System.out.println(newInstance);\n        System.out.println(instance==newInstance);\n    &#125;\n\n表现结果还是和上面饿汉式，也防御不了反射攻击，也需要在构造函数中判断。\n/**\n * @Author：球某\n * @Date：2021/11/17/1:44\n * 静态内部类\n */\npublic class StaticInnerClassSingleton implements Serializable &#123;\n\n    private StaticInnerClassSingleton()&#123;\n        if(InnerClass.singleton!=null)\n            throw new RuntimeException(&quot;单例构造器 禁止反射破坏&quot;);\n    &#125;\n\n    private static class InnerClass&#123;\n       private static StaticInnerClassSingleton singleton=new StaticInnerClassSingleton();\n    &#125;\n\n    public static StaticInnerClassSingleton getInstance()&#123;\n        return InnerClass.singleton;\n    &#125;\n\n    /**\n     * 防止反序列化\n     * @return\n     */\n    private Object readResolve()&#123;\n        return InnerClass.singleton;\n    &#125;\n&#125;\n\n因为静态内部类，也是在使用是才加载，所以也能保证反射的安全。\n懒汉式：序列化攻击：懒汉式public static void main(String[] args) throws Exception&#123;\n\n        LazySingleton instance = LazySingleton.getInstance();\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;instance_file&quot;));\n        oos.writeObject(instance);\n\n        File file = new File(&quot;instance_file&quot;);\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));\n        LazySingleton readObject = (LazySingleton)ois.readObject();\n\n        System.out.println(instance);\n        System.out.println(readObject);\n        System.out.println(instance==readObject);\n    &#125;\n\n结果和上面都是一样，防御不了序列化攻击，也是要提供readResolve()方法。\n/**\n * @Author：小球某\n * @Date：2021/11/16/23:56\n * 懒汉式\n */\npublic class LazySingleton implements Serializable &#123;\n    private LazySingleton()&#123;&#125;;\n\n    private static volatile LazySingleton SINGLETEN;\n\n    public static LazySingleton getInstance()&#123;\n        if(SINGLETEN==null)&#123;//语句1\n            synchronized (LazySingleton.class)&#123;//语句2\n                if(SINGLETEN==null)&#123;\n                    SINGLETEN=new LazySingleton();\n                &#125;\n            &#125;\n        &#125;\n        return SINGLETEN;\n    &#125;\n\n    /**\n     * 防止反序列化\n     * @return\n     */\n    private Object readResolve()&#123;\n        return SINGLETEN;\n    &#125;\n&#125;\n\n反射攻击：懒汉式 public static void main(String[] args) throws Exception&#123;\n\n        LazySingleton instance = LazySingleton.getInstance();\n\n        Class&lt;LazySingleton&gt; aClass = LazySingleton.class;\n        Constructor&lt;LazySingleton&gt; constructor = aClass.getDeclaredConstructor();\n        constructor.setAccessible(true);\n        LazySingleton newInstance = constructor.newInstance(null);\n\n        System.out.println(instance);\n        System.out.println(newInstance);\n        System.out.println(instance==newInstance);\n    &#125;\n\n结果也是一样 不能防御反射的攻击，那么我们继续在构造函数中继续判断。\n/**\n * @Author：小球某\n * @Date：2021/11/16/23:56\n * 懒汉式\n */\npublic class LazySingleton implements Serializable &#123;\n\n    private LazySingleton()&#123;\n        if(SINGLETEN!=null)\n            throw new RuntimeException(&quot;单例构造器 禁止反射破坏&quot;);\n    &#125;;\n\n    private static volatile LazySingleton SINGLETEN;\n\n    public static LazySingleton getInstance()&#123;\n        if(SINGLETEN==null)&#123;//语句1\n            synchronized (LazySingleton.class)&#123;//语句2\n                if(SINGLETEN==null)&#123;\n                    SINGLETEN=new LazySingleton();\n                &#125;\n            &#125;\n        &#125;\n        return SINGLETEN;\n    &#125;\n\n    /**\n     * 防止反序列化\n     * @return\n     */\n    private Object readResolve()&#123;\n        return SINGLETEN;\n    &#125;\n&#125;\n\n继续运行：\n\n结果也达到了我们预期，可是这样真的没用问题了吗。\n我们换个思路，让反射的代码先执行，getInstance()方法后执行试试。\n public static void main(String[] args) throws Exception&#123;\n        //反射先执行\n        Class&lt;LazySingleton&gt; aClass = LazySingleton.class;\n        Constructor&lt;LazySingleton&gt; constructor = aClass.getDeclaredConstructor();\n        constructor.setAccessible(true);\n        LazySingleton newInstance = constructor.newInstance(null);\n\n        LazySingleton instance = LazySingleton.getInstance();\n        System.out.println(instance);\n        System.out.println(newInstance);\n        System.out.println(instance==newInstance);\n    &#125;\n\n运行结果：\n\n结果反射又再次破坏了我们的单例，那么有没有什么办法呢。\n主要是在构造函数里面做判断，其实不管怎么做判断，反射都可以通过打开私有权限 去破坏。\n因为懒汉式最大的特点就是延迟加载，只有用到时候才会加载，那么只要在加载前 执行反射代码的话 就是避免不了被破坏的。所以我们能做的就是尽量的让反射的代码后执行 ，在多线程下 加载的代码 和反射代码是不同线程执行，那么我们就无法避免。\n上面的饿汉式是加载类阶段的时候就会创建出，即使先反射代码先执行，反射也会触发类的加载，从而完成创建，\n在newInstance的时候也就会报错。而静态内部类是由JVM保证的安全。\n小结：懒汉式只能防御反序列化攻击，不能完全防御反射攻击。\n容器单例：反序列化攻击：容器单例 public static void main(String[] args) throws Exception&#123;\n\n        ContainerSingleton instance = ContainerSingleton.getInstance();\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;instance_file&quot;));\n        oos.writeObject(instance);\n\n        File file = new File(&quot;instance_file&quot;);\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));\n        ContainerSingleton readObject = (ContainerSingleton)ois.readObject();\n\n        System.out.println(instance);\n        System.out.println(readObject);\n        System.out.println(instance==readObject);\n    &#125;\n\n也是和大家一样，防御不了序列化攻击，也是要提供readResolve()方法。\n/**\n * @Author：小球某\n * @Date：2021/11/17/1:54\n * 容器实现法\n */\npublic class ContainerSingleton  implements Serializable &#123;\n    private ContainerSingleton()&#123;&#125;;\n\n    private static ConcurrentHashMap&lt;String, ContainerSingleton&gt; map=new ConcurrentHashMap();\n\n    private static String KEY=&quot;singleten&quot;;\n\n    public static ContainerSingleton getInstance()&#123;\n        ContainerSingleton singleten = map.get(KEY);\n        return singleten!=null?singleten:map.computeIfAbsent(KEY,s-&gt; new ContainerSingleton());\n    &#125;\n\n    /**\n     * 防止反序列化\n     * @return\n     */\n    private Object readResolve()&#123;\n        return map.get(KEY);\n    &#125;\n&#125;\n\n反射攻击：容器单例 给构造函数中添加判断 并让反射代码先执行private ContainerSingleton()&#123;\n    if(map.get(KEY)!=null)\n      throw new RuntimeException(&quot;单例构造器 禁止反射破坏&quot;);\n &#125;;\n\n public static void main(String[] args) throws Exception&#123;\n        //反射先执行\n        Class&lt;ContainerSingleton&gt; aClass = ContainerSingleton.class;\n        Constructor&lt;ContainerSingleton&gt; constructor = aClass.getDeclaredConstructor();\n        constructor.setAccessible(true);\n        ContainerSingleton newInstance = constructor.newInstance(null);\n\n        ContainerSingleton instance = ContainerSingleton.getInstance();\n        System.out.println(instance);\n        System.out.println(newInstance);\n        System.out.println(instance==newInstance);\n    &#125;\n\n表现结果也是和懒汉式一样，只能防御住 反射后执行的情况，如果反射先执行就防御不了。\n枚举单例：反序列攻击：枚举单例 public static void main(String[] args) throws Exception&#123;\n        \n        EnumSingleton instance = EnumSingleton.getInstance();\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;instance_file&quot;));\n        oos.writeObject(instance);\n\n        File file = new File(&quot;instance_file&quot;);\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));\n        EnumSingleton readObject =(EnumSingleton) ois.readObject();\n\n        System.out.println(instance.getData());\n        System.out.println(readObject.getData());\n        System.out.println(instance.getData()==readObject.getData());\n\n    &#125;\n\n运行结果：\n\n反射攻击：枚举单例public static void main(String[] args) throws Exception&#123;\n        //反射先执行\n        Class&lt;EnumSingleton&gt; aClass = EnumSingleton.class;\n        Constructor&lt;EnumSingleton&gt; constructor = aClass.getDeclaredConstructor();\n        constructor.setAccessible(true);\n        EnumSingleton newInstance = constructor.newInstance(null);\n\n        EnumSingleton instance = EnumSingleton.getInstance();\n        System.out.println(instance);\n        System.out.println(newInstance);\n        System.out.println(instance==newInstance);\n\n    &#125;\n\n运行结果：\n\nJava规范字规定，每个枚举类型及其定义的枚举变量在JVM中都是唯一的，因此在枚举类型的序列化和反序列化上，Java做了特殊的规定。在序列化的时候Java仅仅是将枚举对象的name属性输到结果中，反序列化的时候则是通过java.lang.Enum的valueOf()方法来根据名字查找枚举对象。也就是说，序列化的时候只将DATASOURCE这个名称输出，反序列化的时候再通过这个名称，查找对应的枚举类型，因此反序列化后的实例也会和之前被序列化的对象实例相同。\n总结：枚举单例 天然的防御反序列化和反射攻击，饿汉式和静态内部类也可以防御 需要提供readResolve()方法和对构造函数判断，懒汉式和容器单例 可以防御反序列化攻击，但不能完全防御反射攻击。代码地址\n","tags":["设计模式"]}]